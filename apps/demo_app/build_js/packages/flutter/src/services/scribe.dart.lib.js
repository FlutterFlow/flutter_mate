// Generated by DDC, the Dart Development Compiler (to JavaScript).
// Version: 3.10.4 (stable) (Tue Dec 9 00:01:55 2025 -0800) on "macos_arm64"
// Module: packages/flutter/src/services/scribe.dart
// Flags: canary, emitLibraryBundle, enableAsserts(true)
dartDevEmbedder.defineLibrary("package:flutter/src/services/scribe.dart", (function load__package$58flutter__src__services__scribe_dart(scribe) {
  'use strict';
  let core = dartDevEmbedder.importLibrary("dart:core", function(lib) {
    core = lib;
  });
  let dart = dartDevEmbedder.importLibrary("dart:_runtime", function(lib) {
    dart = lib;
  });
  let dart_rti = dartDevEmbedder.importLibrary("dart:_rti", function(lib) {
    dart_rti = lib;
  });
  let async = dartDevEmbedder.importLibrary("dart:async", function(lib) {
    async = lib;
  });
  let platform_channel = dartDevEmbedder.importLibrary("package:flutter/src/services/platform_channel.dart", function(lib) {
    platform_channel = lib;
  });
  let message_codecs = dartDevEmbedder.importLibrary("package:flutter/src/services/message_codecs.dart", function(lib) {
    message_codecs = lib;
  });
  let assertions = dartDevEmbedder.importLibrary("package:flutter/src/foundation/assertions.dart", function(lib) {
    assertions = lib;
  });
  let dartx = dartDevEmbedder.importLibrary("dartx", function(lib) {
    dartx = lib;
  });
  var T = {
    boolN: () => (T.boolN = dart.constFn(dart_rti._Universe.eval(dart.typeUniverse, "core|bool?", true)))(),
    FutureOfboolN: () => (T.FutureOfboolN = dart.constFn(dart_rti._Universe.eval(dart.typeUniverse, "async|Future<core|bool?>", true)))(),
    bool: () => (T.bool = dart.constFn(dart_rti._Universe.eval(dart.typeUniverse, "core|bool", true)))(),
    void: () => (T.void = dart.constFn(dart_rti._Universe.eval(dart.typeUniverse, "~", true)))(),
    VoidToFutureOfbool: () => (T.VoidToFutureOfbool = dart.constFn(dart_rti._Universe.eval(dart.typeUniverse, "async|Future<core|bool>()", true)))(),
    VoidToFutureOfvoid: () => (T.VoidToFutureOfvoid = dart.constFn(dart_rti._Universe.eval(dart.typeUniverse, "async|Future<~>()", true)))(),
    MethodChannel: () => (T.MethodChannel = dart.constFn(dart_rti._Universe.eval(dart.typeUniverse, "flutter__src__services__platform_channel|MethodChannel", true)))()
  };
  const CT = Object.create({
    _: () => (C, CT)
  });
  dart.defineLazy(CT, {
    get C1() {
      return C[1] = dart.const(Object.setPrototypeOf({
      }, message_codecs.JSONMethodCodec.prototype));
    },
    get C0() {
      return C[0] = dart.const(Object.setPrototypeOf({
        [MethodChannel__binaryMessenger]: null,
        [MethodChannel_codec]: C[1] || CT.C1,
        [MethodChannel_name]: "flutter/scribe"
      }, platform_channel.OptionalMethodChannel.prototype));
    }
  });
  var C = Array(2).fill(void 0);
  var I = [
    "package:flutter/src/services/scribe.dart",
    "package:flutter/src/services/platform_channel.dart"
  ];
  var _channel = dart.privateName("package:flutter/src/services/scribe.dart", "_channel");
  var MethodChannel__binaryMessenger = dart.privateName("package:flutter/src/services/platform_channel.dart", "MethodChannel._binaryMessenger");
  var MethodChannel_codec = dart.privateName("package:flutter/src/services/platform_channel.dart", "MethodChannel.codec");
  var MethodChannel_name = dart.privateName("package:flutter/src/services/platform_channel.dart", "MethodChannel.name");
  var _as = dart.privateName("dart:_rti", "_as");
  dart.declareClass(scribe, 'Scribe', class Scribe {
    static [_channel] = void 0;
    /*scribe.Scribe._channel*/static get _channel() {
      if (this[_channel] === void 0) {
        this[_channel] = C[0] || CT.C0;
      }
      this[_channel];
      Object.defineProperty(this, "_channel", {
        get() {
          return this[_channel];
        }
      });
      return this._channel;
    }
    static isFeatureAvailable() {
      let $36rec, $36result;
      let t$goto = 0, t$completer = async._makeAsyncAwaitCompleter(T.bool()), t$returnValue, asyncScope = Object.create(null);
      var t$36asyncisFeatureAvailable = async._wrapJsFunctionForAsync((t$errorCode, t$result) => {
        if (t$errorCode === 1) return async._asyncRethrow(t$result, t$completer);
        while (true)
          switch (t$goto) {
            case 0:
              // Function start
              t$goto = 2;
              return async._asyncAwait(0 === dart.global.dartDevEmbedder.hotReloadGeneration ? scribe.Scribe._channel.invokeMethod(T.boolN(), "Scribe.isFeatureAvailable") : ($36rec = scribe.Scribe._channel, $36result = dart.hotReloadCorrectnessChecks($36rec, 'invokeMethod', [T.boolN()], ["Scribe.isFeatureAvailable"], null), $36result == dart.validArgumentsSentinel ? T.FutureOfboolN()[_as]($36rec.invokeMethod(T.boolN(), "Scribe.isFeatureAvailable")) : T.FutureOfboolN()[_as]($36result)), t$36asyncisFeatureAvailable, t$completer);
            case 2:
              // returning from await.
              asyncScope.result = t$result;
              if (asyncScope.result == null) dart.throw(assertions.FlutterError.new("MethodChannel.invokeMethod unexpectedly returned null."));
              t$returnValue = asyncScope.result;
              // goto return
              t$goto = 3;
              break;
            case 3:
              // return
              return async._asyncReturn(t$returnValue, t$completer);
          }
      });
      return async._asyncStartSync(t$36asyncisFeatureAvailable, t$completer);
    }
    static isStylusHandwritingAvailable() {
      let $36rec, $36result;
      let t$goto = 0, t$completer = async._makeAsyncAwaitCompleter(T.bool()), t$returnValue, asyncScope = Object.create(null);
      var t$36asyncisStylusHandwritingAvailable = async._wrapJsFunctionForAsync((t$errorCode, t$result) => {
        if (t$errorCode === 1) return async._asyncRethrow(t$result, t$completer);
        while (true)
          switch (t$goto) {
            case 0:
              // Function start
              t$goto = 2;
              return async._asyncAwait(0 === dart.global.dartDevEmbedder.hotReloadGeneration ? scribe.Scribe._channel.invokeMethod(T.boolN(), "Scribe.isStylusHandwritingAvailable") : ($36rec = scribe.Scribe._channel, $36result = dart.hotReloadCorrectnessChecks($36rec, 'invokeMethod', [T.boolN()], ["Scribe.isStylusHandwritingAvailable"], null), $36result == dart.validArgumentsSentinel ? T.FutureOfboolN()[_as]($36rec.invokeMethod(T.boolN(), "Scribe.isStylusHandwritingAvailable")) : T.FutureOfboolN()[_as]($36result)), t$36asyncisStylusHandwritingAvailable, t$completer);
            case 2:
              // returning from await.
              asyncScope.result = t$result;
              if (asyncScope.result == null) dart.throw(assertions.FlutterError.new("MethodChannel.invokeMethod unexpectedly returned null."));
              t$returnValue = asyncScope.result;
              // goto return
              t$goto = 3;
              break;
            case 3:
              // return
              return async._asyncReturn(t$returnValue, t$completer);
          }
      });
      return async._asyncStartSync(t$36asyncisStylusHandwritingAvailable, t$completer);
    }
    static startStylusHandwriting() {
      return scribe.Scribe._channel.invokeMethod(T.void(), "Scribe.startStylusHandwriting");
    }
  });
  (scribe.Scribe.new = function() {
    ;
  }).prototype = scribe.Scribe.prototype;
  dart.lazyFn(scribe.Scribe.isFeatureAvailable, () => T.VoidToFutureOfbool());
  dart.lazyFn(scribe.Scribe.isStylusHandwritingAvailable, () => T.VoidToFutureOfbool());
  dart.lazyFn(scribe.Scribe.startStylusHandwriting, () => T.VoidToFutureOfvoid());
  dart.addRtiResources(scribe.Scribe, ["flutter__src__services__scribe|Scribe"]);
  dart.setMethodsImmediateTargetSignature(scribe.Scribe, () => dart.global.Object.setPrototypeOf({
    isFeatureAvailable: "package:flutter/src/services/scribe.dart:Scribe",
    isStylusHandwritingAvailable: "package:flutter/src/services/scribe.dart:Scribe",
    startStylusHandwriting: "package:flutter/src/services/scribe.dart:Scribe"
  }, dart.getMethodsImmediateTargets(dart.global.Object.getPrototypeOf(scribe.Scribe))));
  dart.setStaticMethodSignature(scribe.Scribe, () => ['isFeatureAvailable', 'isStylusHandwritingAvailable', 'startStylusHandwriting']);
  dart.setLibraryUri(scribe.Scribe, I[0]);
  dart.setStaticFieldSignature(scribe.Scribe, () => ['_channel']);
  (function() {
  }).prototype = scribe;
  dart.moduleConstCaches.set("packages/flutter/src/services/scribe.dart", C);
  scribe[dartDevEmbedder.linkSymbol] = function link__scribe() {
    dart.classExtends(scribe.Scribe, dartDevEmbedder.importLibrary("dart:core").Object);
    dart_rti._Universe.addRules(dart.typeUniverse, JSON.parse('{"async|Future":{"Future.T":"1"}}'));
  };
  scribe[dart.libraryImportUri] = "package:flutter/src/services/scribe.dart";
  return scribe;
}));
dartDevEmbedder.debugger.setSourceMap("packages/flutter/src/services/scribe.dart", '{"version":3,"sourceRoot":"","sources":["scribe.dart"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA6B6B,sBAAQ;;;;;;;;;;;;;;8EA+Bf;;;;;;;cACG;+FAAM,AAAS,+CAAoB,yCAA7B,0GAA6B,uGAApB,+BAAoB;;;cAA5C;kBAER,iBAAM,UACR,WAAM,4BAAa;AAGrB,8BAAO,iBAAM;;cAAb;;;;AACF;;;YARoB;IAQpB;;;8EA2CoB;;;;;;;cACG;+FAAM,AAAS,+CAAoB,mDAA7B,0GAA6B,iHAApB,+BAAoB;;;cAA5C;kBAER,iBAAM,UACR,WAAM,4BAAa;AAGrB,8BAAO,iBAAM;;cAAb;;;;AACF;;;YARoB;IAQpB;;AAsBE,YAAO,AAAS,+CAAmB;IACrC;;;;EACF","file":"../../../../../../../../../packages/flutter/src/services/scribe.dart.lib.js"}');

//# sourceMappingURL=scribe.dart.lib.js.map
