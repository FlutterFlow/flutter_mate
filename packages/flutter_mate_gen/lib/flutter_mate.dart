/// Flutter Mate Bundle - Auto-generated single-file library
///
/// This file combines flutter_mate and flutter_mate_types into a single
/// library that compiles to a single JS module for web injection.
///
/// Generated by: dart run bin/bundle_generator.dart
/// Date: 2026-01-28T18:18:54.589767
///
/// DO NOT EDIT - regenerate instead.
library flutter_mate;

import 'dart:async';
import 'dart:convert';
import 'dart:developer';
import 'dart:ui' as ui;
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/scheduler.dart';
import 'package:flutter/services.dart';
import 'package:flutter/widgets.dart';

// ════════════════════════════════════════════════════════════════════════════
// Source: package:flutter_mate_types/src/snapshot.dart
// ════════════════════════════════════════════════════════════════════════════

/// Snapshot types shared between Flutter Mate SDK and CLI.
///
/// These types represent the widget tree snapshot with semantics information.
/// They are pure Dart with no Flutter dependencies.

/// A combined snapshot of the widget tree with semantics information.
class CombinedSnapshot {
  final bool success;
  final String? error;
  final DateTime timestamp;
  final List<CombinedNode> nodes;
  final Map<String, CombinedNode> _nodesByRef;

  CombinedSnapshot({
    required this.success,
    this.error,
    required this.timestamp,
    required this.nodes,
  }) : _nodesByRef = {for (final n in nodes) n.ref: n};

  /// Get a node by its ref (e.g., 'w5')
  CombinedNode? operator [](String ref) => _nodesByRef[ref];

  /// Get only nodes that have semantics attached
  List<CombinedNode> get withSemantics =>
      nodes.where((n) => n.semantics != null).toList();

  /// Get root nodes (nodes with no parent)
  List<CombinedNode> get roots => nodes.where((n) => n.depth == 0).toList();

  /// Create from JSON
  factory CombinedSnapshot.fromJson(Map<String, dynamic> json) {
    return CombinedSnapshot(
      success: json['success'] as bool? ?? false,
      error: json['error'] as String?,
      timestamp: json['timestamp'] != null
          ? DateTime.parse(json['timestamp'] as String)
          : DateTime.now(),
      nodes: (json['nodes'] as List<dynamic>?)
              ?.map((n) => CombinedNode.fromJson(n as Map<String, dynamic>))
              .toList() ??
          [],
    );
  }

  /// Convert to JSON
  Map<String, dynamic> toJson() => {
        'success': success,
        if (error != null) 'error': error,
        'timestamp': timestamp.toIso8601String(),
        'nodeCount': nodes.length,
        'nodesWithSemantics': withSemantics.length,
        'nodes': nodes.map((n) => n.toJson()).toList(),
      };
}

/// A node in the combined widget tree.
class CombinedNode {
  /// Unique reference for this node (e.g., 'w0', 'w1')
  final String ref;

  /// Widget type name (e.g., 'TextField', 'ElevatedButton')
  final String widget;

  /// Depth in the tree (0 = root)
  final int depth;

  /// Bounding box on screen
  final CombinedRect? bounds;

  /// Child node refs
  final List<String> children;

  /// Semantics information (null if widget has no semantics)
  final SemanticsInfo? semantics;

  /// Text content for informative widgets
  final String? textContent;

  CombinedNode({
    required this.ref,
    required this.widget,
    required this.depth,
    this.bounds,
    required this.children,
    this.semantics,
    this.textContent,
  });

  /// Whether this node has semantics attached
  bool get hasSemantics => semantics != null;

  /// Whether this node can be interacted with
  bool get isInteractive => semantics?.actions.isNotEmpty == true;

  /// Get center point for gesture interactions
  ({double x, double y})? get center => bounds?.center;

  /// Whether this node has any meaningful info beyond just widget type.
  /// Used for compact mode filtering.
  bool get hasAdditionalInfo {
    // Widget name contains a key (e.g., "-[<'database-icon'>]" or "-[GlobalKey#...]")
    // These keys often contain semantic meaning
    if (widget.contains('-[')) return true;

    // Has text content
    if (textContent?.isNotEmpty == true) return true;

    final sem = semantics;
    if (sem == null) return false;

    // Has semantic label, value, or hint
    if (sem.label?.isNotEmpty == true) return true;
    if (sem.value?.isNotEmpty == true) return true;
    if (sem.hint?.isNotEmpty == true) return true;

    // Has actions
    if (sem.actions.isNotEmpty) return true;

    // Has meaningful flags
    if (sem.flags.isNotEmpty) return true;

    // Has validation state
    if (sem.validationResult != null) return true;

    // Has scroll info
    if (sem.scrollPosition != null) return true;

    // Has tooltip
    if (sem.tooltip?.isNotEmpty == true) return true;

    // Has heading level
    if (sem.headingLevel != null && sem.headingLevel! > 0) return true;

    // Has link
    if (sem.linkUrl?.isNotEmpty == true) return true;

    // Has input type
    if (sem.inputType != null && sem.inputType != 'none') return true;

    return false;
  }

  /// Create from JSON
  factory CombinedNode.fromJson(Map<String, dynamic> json) {
    return CombinedNode(
      ref: json['ref'] as String? ?? '',
      widget: json['widget'] as String? ?? '?',
      depth: json['depth'] as int? ?? 0,
      bounds: json['bounds'] != null
          ? CombinedRect.fromJson(json['bounds'] as Map<String, dynamic>)
          : null,
      children: (json['children'] as List<dynamic>?)?.cast<String>() ?? [],
      semantics: json['semantics'] != null
          ? SemanticsInfo.fromJson(json['semantics'] as Map<String, dynamic>)
          : null,
      textContent: json['textContent'] as String?,
    );
  }

  /// Convert to JSON
  Map<String, dynamic> toJson() => {
        'ref': ref,
        'widget': widget,
        'depth': depth,
        if (bounds != null) 'bounds': bounds!.toJson(),
        'children': children,
        if (semantics != null) 'semantics': semantics!.toJson(),
        if (textContent != null) 'textContent': textContent,
      };
}

/// Semantics information extracted from a SemanticsNode.
class SemanticsInfo {
  /// Semantics node ID
  final int id;

  /// Unique identifier for this semantics node
  final String? identifier;

  /// Accessibility label (e.g., 'Email', 'Submit button')
  final String? label;

  /// Current value (e.g., text field contents, slider position)
  final String? value;

  /// Accessibility hint (e.g., 'Double tap to activate')
  final String? hint;

  /// Tooltip text
  final String? tooltip;

  /// For sliders: the value after increasing
  final String? increasedValue;

  /// For sliders: the value after decreasing
  final String? decreasedValue;

  /// Semantic flags (e.g., 'isButton', 'isTextField', 'isFocusable')
  final Set<String> flags;

  /// Available actions (e.g., 'tap', 'focus', 'setText')
  final Set<String> actions;

  /// Text direction (ltr, rtl)
  final String? textDirection;

  /// Start of text selection
  final int? textSelectionBase;

  /// End of text selection
  final int? textSelectionExtent;

  /// Maximum allowed value length
  final int? maxValueLength;

  /// Current value length
  final int? currentValueLength;

  /// Total number of scrollable children
  final int? scrollChildCount;

  /// Index of first visible semantic child
  final int? scrollIndex;

  /// Current scroll position in logical pixels
  final double? scrollPosition;

  /// Maximum scroll extent
  final double? scrollExtentMax;

  /// Minimum scroll extent
  final double? scrollExtentMin;

  /// Heading level (1-6, 0 if not a heading)
  final int? headingLevel;

  /// Link URL if this is a link
  final String? linkUrl;

  /// Semantic role (e.g., 'button', 'textField', 'slider')
  final String? role;

  /// Input type for text fields (e.g., 'text', 'number', 'email')
  final String? inputType;

  /// Validation result for form fields (none, valid, invalid)
  final String? validationResult;

  /// Platform view ID if this is a platform view
  final int? platformViewId;

  /// IDs of nodes this node controls
  final Set<String>? controlsNodes;

  SemanticsInfo({
    required this.id,
    this.identifier,
    this.label,
    this.value,
    this.hint,
    this.tooltip,
    this.increasedValue,
    this.decreasedValue,
    required this.flags,
    required this.actions,
    this.textDirection,
    this.textSelectionBase,
    this.textSelectionExtent,
    this.maxValueLength,
    this.currentValueLength,
    this.scrollChildCount,
    this.scrollIndex,
    this.scrollPosition,
    this.scrollExtentMax,
    this.scrollExtentMin,
    this.headingLevel,
    this.linkUrl,
    this.role,
    this.inputType,
    this.validationResult,
    this.platformViewId,
    this.controlsNodes,
  });

  /// Check if this has a specific action
  bool hasAction(String action) => actions.contains(action);

  /// Check if this has a specific flag
  bool hasFlag(String flag) => flags.contains(flag);

  /// Check if this element is scrollable
  bool get isScrollable =>
      actions.contains('scrollUp') ||
      actions.contains('scrollDown') ||
      actions.contains('scrollLeft') ||
      actions.contains('scrollRight');

  /// Check if this is a form field with validation error
  bool get hasValidationError => validationResult == 'invalid';

  /// Check if this is a form field that passed validation
  bool get isValid => validationResult == 'valid';

  /// Create from JSON
  factory SemanticsInfo.fromJson(Map<String, dynamic> json) {
    return SemanticsInfo(
      id: json['id'] as int? ?? 0,
      identifier: json['identifier'] as String?,
      label: json['label'] as String?,
      value: json['value'] as String?,
      hint: json['hint'] as String?,
      tooltip: json['tooltip'] as String?,
      increasedValue: json['increasedValue'] as String?,
      decreasedValue: json['decreasedValue'] as String?,
      flags: (json['flags'] as List<dynamic>?)?.cast<String>().toSet() ?? {},
      actions:
          (json['actions'] as List<dynamic>?)?.cast<String>().toSet() ?? {},
      textDirection: json['textDirection'] as String?,
      textSelectionBase: json['textSelectionBase'] as int?,
      textSelectionExtent: json['textSelectionExtent'] as int?,
      maxValueLength: json['maxValueLength'] as int?,
      currentValueLength: json['currentValueLength'] as int?,
      scrollChildCount: json['scrollChildCount'] as int?,
      scrollIndex: json['scrollIndex'] as int?,
      scrollPosition: (json['scrollPosition'] as num?)?.toDouble(),
      scrollExtentMax: (json['scrollExtentMax'] as num?)?.toDouble(),
      scrollExtentMin: (json['scrollExtentMin'] as num?)?.toDouble(),
      headingLevel: json['headingLevel'] as int?,
      linkUrl: json['linkUrl'] as String?,
      role: json['role'] as String?,
      inputType: json['inputType'] as String?,
      validationResult: json['validationResult'] as String?,
      platformViewId: json['platformViewId'] as int?,
      controlsNodes:
          (json['controlsNodes'] as List<dynamic>?)?.cast<String>().toSet(),
    );
  }

  /// Convert to JSON
  Map<String, dynamic> toJson() => {
        'id': id,
        if (identifier != null) 'identifier': identifier,
        if (label != null) 'label': label,
        if (value != null && value!.isNotEmpty) 'value': value,
        if (hint != null) 'hint': hint,
        if (tooltip != null) 'tooltip': tooltip,
        if (increasedValue != null) 'increasedValue': increasedValue,
        if (decreasedValue != null) 'decreasedValue': decreasedValue,
        'flags': flags.toList(),
        'actions': actions.toList(),
        if (textDirection != null) 'textDirection': textDirection,
        if (textSelectionBase != null) 'textSelectionBase': textSelectionBase,
        if (textSelectionExtent != null)
          'textSelectionExtent': textSelectionExtent,
        if (maxValueLength != null) 'maxValueLength': maxValueLength,
        if (currentValueLength != null)
          'currentValueLength': currentValueLength,
        if (scrollChildCount != null) 'scrollChildCount': scrollChildCount,
        if (scrollIndex != null) 'scrollIndex': scrollIndex,
        if (scrollPosition != null) 'scrollPosition': scrollPosition,
        if (scrollExtentMax != null && scrollExtentMax!.isFinite)
          'scrollExtentMax': scrollExtentMax,
        if (scrollExtentMin != null) 'scrollExtentMin': scrollExtentMin,
        if (headingLevel != null && headingLevel! > 0)
          'headingLevel': headingLevel,
        if (linkUrl != null) 'linkUrl': linkUrl,
        if (role != null && role != 'none') 'role': role,
        if (inputType != null && inputType != 'none') 'inputType': inputType,
        if (validationResult != null && validationResult != 'none')
          'validationResult': validationResult,
        if (platformViewId != null) 'platformViewId': platformViewId,
        if (controlsNodes != null && controlsNodes!.isNotEmpty)
          'controlsNodes': controlsNodes!.toList(),
      };
}

/// Simple rect class for node bounds.
class CombinedRect {
  final double x;
  final double y;
  final double width;
  final double height;

  CombinedRect({
    required this.x,
    required this.y,
    required this.width,
    required this.height,
  });

  /// Center point of the rect
  ({double x, double y}) get center => (
        x: x + width / 2,
        y: y + height / 2,
      );

  /// Check if this rect has the same bounds as another (within tolerance)
  bool sameBoundsAs(CombinedRect other, {double tolerance = 1.0}) {
    return (x - other.x).abs() <= tolerance &&
        (y - other.y).abs() <= tolerance &&
        (width - other.width).abs() <= tolerance &&
        (height - other.height).abs() <= tolerance;
  }

  /// Check if this is a zero-area rect
  bool get isZeroArea => width <= 0 || height <= 0;

  /// Create from JSON
  factory CombinedRect.fromJson(Map<String, dynamic> json) {
    return CombinedRect(
      x: (json['x'] as num?)?.toDouble() ?? 0,
      y: (json['y'] as num?)?.toDouble() ?? 0,
      width: (json['width'] as num?)?.toDouble() ?? 0,
      height: (json['height'] as num?)?.toDouble() ?? 0,
    );
  }

  /// Convert to JSON
  Map<String, double> toJson() => {
        'x': x,
        'y': y,
        'width': width,
        'height': height,
      };
}

// ════════════════════════════════════════════════════════════════════════════
// Source: package:flutter_mate/src/core/flutter_mate.dart
// ════════════════════════════════════════════════════════════════════════════

/// Flutter Mate SDK — Automate Flutter apps
///
/// Use this class for:
/// - **AI agents** that navigate and interact with your UI
/// - **Automated testing** without widget keys
/// - **Accessibility automation** using the semantics tree
///
/// ## Quick Start
///
/// ```dart
/// // 1. Initialize at app startup
/// await FlutterMate.initialize();
///
/// // 2. Get UI snapshot with element refs
/// final snapshot = await FlutterMate.snapshot();
/// print(snapshot);
///
/// // 3. Interact with elements
/// await FlutterMate.tap('w18');  // auto: semantic or gesture
/// await FlutterMate.setText('w9', 'hello@example.com');  // semantic action
/// await FlutterMate.typeText('w10', 'hello@example.com');  // keyboard sim
/// ```
///
/// ## Smart Action System
///
/// Actions like `tap`, `longPress`, and `scroll` are **smart**:
/// - Try semantic action first (if the node has the action)
/// - Fall back to gesture-based action automatically
///
/// ### Semantic Actions (on Semantics widgets)
/// - `setText(ref, text)` — uses `SemanticsAction.setText`
/// - `focus(ref)` — uses `SemanticsAction.focus`
///
/// ### Keyboard Simulation (on actual widgets)
/// - `typeText(ref, text)` — platform messages (like real typing)
/// - `pressKey(key)` — simulates keyboard events
///
/// ## Snapshot Structure
///
/// The snapshot shows the inspector tree (like DevTools) with semantics
/// only attached to explicit `Semantics` widgets:
///
/// ```
/// • w9: Semantics "Email" [tap, focus, setText] (TextField)
///   • w10: TextField (bounds)
/// ```
///
/// - Use `w9` (Semantics) for semantic actions like `setText`
/// - Use `w10` (TextField) for keyboard actions like `typeText`
/// - Use either for `tap` (it auto-detects the best approach)
///
/// ## External Control via VM Service
///
/// When `initialize()` is called, service extensions are registered
/// (`ext.flutter_mate.*`) allowing external control via the CLI:
///
/// ```bash
/// flutter_mate --uri ws://127.0.0.1:12345/abc=/ws snapshot
/// flutter_mate --uri ws://127.0.0.1:12345/abc=/ws setText w9 "text"
/// flutter_mate --uri ws://127.0.0.1:12345/abc=/ws typeText w10 "text"
/// ```
class FlutterMate {
  static SemanticsHandle? _semanticsHandle;
  static bool _initialized = false;

  // Cached snapshot for ref -> semantics ID translation
  // ignore: unnecessary_getters_setters
  static CombinedSnapshot? _lastSnapshotValue;

  // Cached Elements from inspector tree for ref -> Element lookup
  static final Map<String, Element> cachedElements = {};

  // Registry for text controllers (for in-app agent usage)
  static final Map<String, TextEditingController> _textControllers = {};

  /// Get the last snapshot (for internal use by other SDK modules)
  // ignore: unnecessary_getters_setters
  static CombinedSnapshot? get lastSnapshot => _lastSnapshotValue;

  /// Set the last snapshot (for internal use by other SDK modules)
  // ignore: unnecessary_getters_setters
  static set lastSnapshot(CombinedSnapshot? value) =>
      _lastSnapshotValue = value;

  /// Register a TextEditingController for use with fillByName
  ///
  /// ```dart
  /// FlutterMate.registerTextField('email', _emailController);
  /// ```
  static void registerTextField(String name, TextEditingController controller) {
    _textControllers[name.toLowerCase()] = controller;
  }

  /// Unregister a TextEditingController
  static void unregisterTextField(String name) {
    _textControllers.remove(name.toLowerCase());
  }

  /// Fill a text field by its registered name
  ///
  /// ```dart
  /// await FlutterMate.fillByName('email', 'hello@example.com');
  /// ```
  static Future<bool> fillByName(String name, String text) async {
    final controller = _textControllers[name.toLowerCase()];
    if (controller == null) {
      debugPrint('FlutterMate: No controller registered for "$name"');
      debugPrint('  Registered: ${_textControllers.keys.join(', ')}');
      return false;
    }
    controller.text = text;
    return true;
  }

  /// Initialize Flutter Mate
  ///
  /// Call this once at app startup (typically in main()).
  /// This enables semantics which is required for UI inspection.
  ///
  /// Can be called before or after runApp() - it will wait appropriately.
  static Future<void> initialize() async {
    if (_initialized) return;

    WidgetsFlutterBinding.ensureInitialized();

    // Enable semantics - must keep handle alive
    _semanticsHandle = RendererBinding.instance.ensureSemantics();

    // Register service extensions for VM Service access (CLI)
    FlutterMateServiceExtensions.register();

    _initialized = true;
    debugPrint('FlutterMate: Initialized (semantics enabled)');
  }

  /// Initialize for widget tests (use with tester.ensureSemantics())
  ///
  /// In tests, use tester.ensureSemantics() for semantics handling,
  /// then call this to enable FlutterMate without creating a second handle.
  ///
  /// This also enables test mode which skips real delays (incompatible with FakeAsync).
  ///
  /// ```dart
  /// testWidgets('my test', (tester) async {
  ///   final handle = tester.ensureSemantics();
  ///   FlutterMate.initializeForTest();
  ///   // ... test code ...
  ///   handle.dispose();
  /// });
  /// ```
  static void initializeForTest() {
    _initialized = true;
    _testMode = true;
  }

  static bool _testMode = false;

  /// Whether running in test mode (skips real delays)
  static bool get isTestMode => _testMode;

  /// Delay that respects test mode (skips in FakeAsync environment)
  static Future<void> delay(Duration duration) async {
    if (!_testMode) {
      await Future.delayed(duration);
    }
  }

  /// Dispatch a pointer event through the appropriate binding
  ///
  /// In test mode, uses WidgetsBinding which properly integrates with FakeAsync.
  /// At runtime, uses GestureBinding directly.
  static void dispatchPointerEvent(PointerEvent event) {
    // Use WidgetsBinding if available (works in both test and runtime)
    // This properly integrates with the test binding's event queue
    WidgetsBinding.instance.handlePointerEvent(event);
  }

  // Note: In debug builds, Flutter allows client ID -1 as a magic value
  // that bypasses client ID verification. This lets us send text input
  // without needing to intercept the channel to capture the real ID.
  // See: TextInput._handleTextInputInvocation in Flutter SDK

  /// Dispatch text input via platform message simulation
  ///
  /// Uses the same mechanism as Flutter's TestTextInput - injects a
  /// platform message to simulate keyboard input.
  ///
  /// Uses client ID -1 which is a magic value in debug builds that
  /// bypasses client ID verification.
  static Future<void> dispatchTextInput(String text) async {
    const codec = JSONMethodCodec();

    // Use client ID -1 (magic value in debug builds that bypasses verification)
    // See: TextInput._handleTextInputInvocation in Flutter SDK
    const int magicClientId = -1;

    // Use channelBuffers.push which is the modern approach
    ServicesBinding.instance.channelBuffers.push(
      'flutter/textinput',
      codec.encodeMethodCall(MethodCall(
        'TextInputClient.updateEditingState',
        <dynamic>[
          magicClientId,
          <String, dynamic>{
            'text': text,
            'selectionBase': text.length,
            'selectionExtent': text.length,
            'composingBase': -1,
            'composingExtent': -1,
          },
        ],
      )),
      (ByteData? response) {
        // Response handling (usually empty)
      },
    );

    await delay(const Duration(milliseconds: 50));
  }

  /// Wait for the UI to be ready (call after runApp if needed)
  static Future<void> waitForFirstFrame() async {
    final completer = Completer<void>();
    SchedulerBinding.instance.addPostFrameCallback((_) {
      if (!completer.isCompleted) {
        completer.complete();
      }
    });
    // Schedule a frame in case one isn't pending
    SchedulerBinding.instance.scheduleFrame();
    await completer.future;
    // Give semantics tree time to build
    await delay(const Duration(milliseconds: 100));
  }

  /// Dispose Flutter Mate resources
  static void dispose() {
    _semanticsHandle?.dispose();
    _semanticsHandle = null;
    _initialized = false;
  }

  /// Ensure FlutterMate is initialized
  static void ensureInitialized() {
    if (!_initialized) {
      throw StateError(
        'FlutterMate not initialized. Call FlutterMate.initialize() first.',
      );
    }
  }
}

// ════════════════════════════════════════════════════════════════════════════
// Source: package:flutter_mate/src/snapshot/screenshot.dart
// ════════════════════════════════════════════════════════════════════════════

/// Screenshot capture service for Flutter Mate.
///
/// Provides methods to capture screenshots of the entire app or specific elements.
class ScreenshotService {
  /// Capture a screenshot of the entire app.
  ///
  /// Returns PNG-encoded bytes of the screenshot.
  ///
  /// ```dart
  /// final bytes = await ScreenshotService.capture();
  /// // Save to file or send to agent
  /// ```
  static Future<Uint8List?> capture({double pixelRatio = 1.0}) async {
    FlutterMate.ensureInitialized();

    try {
      // Get the render view from the binding
      final renderViews = RendererBinding.instance.renderViews;
      if (renderViews.isEmpty) {
        debugPrint('FlutterMate: No render views available');
        return null;
      }

      final renderView = renderViews.first;
      final size = renderView.size;

      // Create an image from the render view
      final image = await _captureRenderObject(renderView, size, pixelRatio);
      if (image == null) return null;

      // Encode to PNG
      final byteData = await image.toByteData(format: ui.ImageByteFormat.png);
      image.dispose();

      return byteData?.buffer.asUint8List();
    } catch (e, stack) {
      debugPrint('FlutterMate: Screenshot capture failed: $e\n$stack');
      return null;
    }
  }

  /// Capture a screenshot of a specific element by ref.
  ///
  /// Returns PNG-encoded bytes of the element's screenshot, or null if not found.
  ///
  /// ```dart
  /// final bytes = await ScreenshotService.captureElement('w15');
  /// ```
  static Future<Uint8List?> captureElement(String ref,
      {double pixelRatio = 1.0}) async {
    FlutterMate.ensureInitialized();

    try {
      // Find the element from cached elements
      final element = FlutterMate.cachedElements[ref];
      if (element == null) {
        debugPrint('FlutterMate: Element not found: $ref');
        return null;
      }

      // Find the render object
      RenderObject? renderObject;
      if (element is RenderObjectElement) {
        renderObject = element.renderObject;
      } else {
        // Search for a render object in descendants
        void findRenderObject(Element el) {
          if (renderObject != null) return;
          if (el is RenderObjectElement) {
            renderObject = el.renderObject;
            return;
          }
          el.visitChildren(findRenderObject);
        }

        findRenderObject(element);
      }

      if (renderObject == null) {
        debugPrint('FlutterMate: No render object for: $ref');
        return null;
      }

      // Get the size of the render object
      final size = renderObject!.paintBounds.size;
      if (size.isEmpty) {
        debugPrint('FlutterMate: Element has zero size: $ref');
        return null;
      }

      // Capture the render object
      final image = await _captureRenderObject(renderObject!, size, pixelRatio);
      if (image == null) return null;

      // Encode to PNG
      final byteData = await image.toByteData(format: ui.ImageByteFormat.png);
      image.dispose();

      return byteData?.buffer.asUint8List();
    } catch (e, stack) {
      debugPrint('FlutterMate: Element screenshot failed: $e\n$stack');
      return null;
    }
  }

  /// Capture a render object to an image.
  static Future<ui.Image?> _captureRenderObject(
    RenderObject renderObject,
    ui.Size size,
    double pixelRatio,
  ) async {
    try {
      // Use OffsetLayer.toImage if available (for most render objects)
      final layer = renderObject.debugLayer;
      if (layer is OffsetLayer) {
        final image = await layer.toImage(
          renderObject.paintBounds,
          pixelRatio: pixelRatio,
        );
        return image;
      }

      debugPrint('FlutterMate: Unsupported layer type: ${layer.runtimeType}');
      return null;
    } catch (e) {
      debugPrint('FlutterMate: Failed to capture render object: $e');
      return null;
    }
  }

  /// Get screenshot as base64-encoded PNG string.
  ///
  /// Useful for transmitting over VM Service or JSON.
  static Future<String?> captureAsBase64({double pixelRatio = 1.0}) async {
    final bytes = await capture(pixelRatio: pixelRatio);
    if (bytes == null) return null;

    // Convert to base64
    return _bytesToBase64(bytes);
  }

  /// Get element screenshot as base64-encoded PNG string.
  static Future<String?> captureElementAsBase64(String ref,
      {double pixelRatio = 1.0}) async {
    final bytes = await captureElement(ref, pixelRatio: pixelRatio);
    if (bytes == null) return null;

    return _bytesToBase64(bytes);
  }

  static String _bytesToBase64(Uint8List bytes) {
    const chars =
        'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    final buffer = StringBuffer();
    final len = bytes.length;
    var i = 0;

    while (i < len) {
      final b1 = bytes[i++];
      final b2 = i < len ? bytes[i++] : 0;
      final b3 = i < len ? bytes[i++] : 0;

      buffer.write(chars[(b1 >> 2) & 0x3F]);
      buffer.write(chars[((b1 & 0x03) << 4) | ((b2 >> 4) & 0x0F)]);
      buffer.write(
          i > len + 1 ? '=' : chars[((b2 & 0x0F) << 2) | ((b3 >> 6) & 0x03)]);
      buffer.write(i > len ? '=' : chars[b3 & 0x3F]);
    }

    return buffer.toString();
  }
}

// ════════════════════════════════════════════════════════════════════════════
// Source: package:flutter_mate/src/core/semantics_utils.dart
// ════════════════════════════════════════════════════════════════════════════

/// Utility functions for extracting semantics information
///
/// These are used by both the snapshot system and the service extensions
/// for debugging.

/// Extract action names from SemanticsData
List<String> getActionsFromData(SemanticsData data) {
  final actions = <String>[];
  if (data.hasAction(SemanticsAction.tap)) actions.add('tap');
  if (data.hasAction(SemanticsAction.longPress)) actions.add('longPress');
  if (data.hasAction(SemanticsAction.scrollLeft)) actions.add('scrollLeft');
  if (data.hasAction(SemanticsAction.scrollRight)) actions.add('scrollRight');
  if (data.hasAction(SemanticsAction.scrollUp)) actions.add('scrollUp');
  if (data.hasAction(SemanticsAction.scrollDown)) actions.add('scrollDown');
  if (data.hasAction(SemanticsAction.focus)) actions.add('focus');
  if (data.hasAction(SemanticsAction.setText)) actions.add('setText');
  if (data.hasAction(SemanticsAction.increase)) actions.add('increase');
  if (data.hasAction(SemanticsAction.decrease)) actions.add('decrease');
  if (data.hasAction(SemanticsAction.copy)) actions.add('copy');
  if (data.hasAction(SemanticsAction.cut)) actions.add('cut');
  if (data.hasAction(SemanticsAction.paste)) actions.add('paste');
  return actions;
}

/// Extract flag names from SemanticsData
List<String> getFlagsFromData(SemanticsData data) {
  final flags = <String>[];

  void checkFlag(SemanticsFlag flag, String name) {
    // ignore: deprecated_member_use
    if (data.hasFlag(flag)) flags.add(name);
  }

  checkFlag(SemanticsFlag.isButton, 'isButton');
  checkFlag(SemanticsFlag.isTextField, 'isTextField');
  checkFlag(SemanticsFlag.isLink, 'isLink');
  checkFlag(SemanticsFlag.isFocusable, 'isFocusable');
  checkFlag(SemanticsFlag.isFocused, 'isFocused');
  checkFlag(SemanticsFlag.isEnabled, 'isEnabled');
  checkFlag(SemanticsFlag.isChecked, 'isChecked');
  checkFlag(SemanticsFlag.isSelected, 'isSelected');
  checkFlag(SemanticsFlag.isToggled, 'isToggled');
  checkFlag(SemanticsFlag.isHeader, 'isHeader');
  checkFlag(SemanticsFlag.isSlider, 'isSlider');
  checkFlag(SemanticsFlag.isImage, 'isImage');
  checkFlag(SemanticsFlag.isObscured, 'isObscured');
  checkFlag(SemanticsFlag.isReadOnly, 'isReadOnly');
  checkFlag(SemanticsFlag.isMultiline, 'isMultiline');

  return flags;
}

/// Get the root semantics node from the current render tree
SemanticsNode? getRootSemanticsNode() {
  for (final view in RendererBinding.instance.renderViews) {
    if (view.owner?.semanticsOwner?.rootSemanticsNode != null) {
      return view.owner!.semanticsOwner!.rootSemanticsNode;
    }
  }
  return null;
}

/// Search for a semantics node by ID in the tree
SemanticsNode? searchSemanticsNodeById(int nodeId) {
  final rootNode = getRootSemanticsNode();
  if (rootNode == null) return null;
  return _searchNode(rootNode, nodeId);
}

SemanticsNode? _searchNode(SemanticsNode node, int targetId) {
  if (node.id == targetId) return node;

  SemanticsNode? found;
  node.visitChildren((child) {
    final result = _searchNode(child, targetId);
    if (result != null) {
      found = result;
      return false;
    }
    return true;
  });
  return found;
}

// ════════════════════════════════════════════════════════════════════════════
// Source: package:flutter_mate/src/snapshot/snapshot.dart
// ════════════════════════════════════════════════════════════════════════════

/// Service for capturing UI snapshots
///
/// Uses Flutter's WidgetInspectorService for the summary tree (same as DevTools)
/// then attaches semantics info for AI/automation interactions.
class SnapshotService {
  /// Get a snapshot of the current UI
  ///
  /// Returns a [CombinedSnapshot] containing the widget tree with semantics.
  /// Each node has a ref (w0, w1, w2...) that can be used for interactions.
  ///
  /// Uses Flutter's WidgetInspectorService to get the same tree that DevTools
  /// shows - only user-created widgets, not framework internals.
  ///
  /// Options:
  /// - [compact]: If true, filters to only nodes with meaningful info
  ///   (text, semantics, actions, flags). This reduces output size significantly.
  /// - [maxDepth]: If provided, limits tree traversal to this depth. Useful for
  ///   large UIs where you only need the top-level structure.
  /// - [fromRef]: If provided, starts the snapshot from this element as root.
  ///   Requires a previous snapshot to have been taken to map refs to elements.
  ///
  /// ```dart
  /// final snapshot = await SnapshotService.snapshot();
  /// print(snapshot);
  ///
  /// // Compact mode - only nodes with info
  /// final compact = await SnapshotService.snapshot(compact: true);
  ///
  /// // Limited depth - only top 3 levels
  /// final shallow = await SnapshotService.snapshot(maxDepth: 3);
  ///
  /// // Subtree from specific element
  /// final subtree = await SnapshotService.snapshot(fromRef: 'w15');
  /// ```
  static Future<CombinedSnapshot> snapshot({
    bool compact = false,
    int? maxDepth,
    String? fromRef,
  }) async {
    FlutterMate.ensureInitialized();

    // Clear caches for fresh detection
    _offstageStatusCache.clear();
    _parentChildOffstageMap.clear();

    // Wait for first frame if needed
    final rootElement = WidgetsBinding.instance.rootElement;
    if (rootElement == null) {
      await FlutterMate.waitForFirstFrame();
    }

    if (WidgetsBinding.instance.rootElement == null) {
      return CombinedSnapshot(
        success: false,
        error: 'No root element found. Is the UI rendered?',
        timestamp: DateTime.now(),
        nodes: [],
      );
    }

    try {
      // Use Flutter's WidgetInspectorService to get the summary tree
      // This is the same tree that DevTools shows - only user widgets
      final service = WidgetInspectorService.instance;
      const groupName = 'flutter_mate_snapshot';

      final jsonStr = service.getRootWidgetSummaryTree(groupName);

      final treeJson = jsonDecode(jsonStr) as Map<String, dynamic>?;
      if (treeJson == null) {
        return CombinedSnapshot(
          success: false,
          error: 'Failed to get widget tree from inspector',
          timestamp: DateTime.now(),
          nodes: [],
        );
      }

      // Track used semantics node IDs to avoid duplication
      final usedSemanticsIds = <int>{};

      // Normalize text for comparison
      String normalizeText(String s) {
        return s
            .toLowerCase()
            .replaceAll(RegExp(r'[\ufffc\ufffd]'), '')
            .replaceAll(RegExp(r'[^\x20-\x7E]'), '')
            .replaceAll(RegExp(r'\s+'), ' ')
            .trim();
      }

      // Parse the inspector tree and attach semantics using toObject
      final nodes = <CombinedNode>[];
      int refCounter = 0;

      // Clear cached elements for fresh snapshot
      FlutterMate.cachedElements.clear();

      // Returns the set of claimed text from this subtree (for parent deduplication)
      // Note: We always walk the full tree to keep refs stable.
      // Depth filtering is applied AFTER the walk to preserve ref numbering.
      Set<String> walkInspectorNode(Map<String, dynamic> node, int depth) {
        final description = node['description'] as String? ?? '';
        final widgetType = _extractWidgetType(description);
        final valueId = node['valueId'] as String?;
        final childrenJson = node['children'] as List<dynamic>? ?? [];

        final ref = 'w${refCounter++}';

        CombinedRect? bounds;
        SemanticsInfo? semantics;
        String? textContent;
        RenderObject? ro;

        // Use toObject to get the actual Element from valueId
        if (valueId != null) {
          try {
            // ignore: invalid_use_of_protected_member
            final obj = service.toObject(valueId, groupName);
            if (obj is Element) {
              // Check if this element is offstage (not being painted)
              // This catches widgets from previous routes, Offstage widgets, etc.
              if (_isElementOffstage(obj)) {
                // Skip offstage elements entirely (don't process children either)
                return <String>{};
              }

              // Cache the Element for ref lookup
              FlutterMate.cachedElements[ref] = obj;

              // Find the RenderObject first (needed for text extraction and bounds)
              if (obj is RenderObjectElement) {
                ro = obj.renderObject;
              } else {
                void findRenderObject(Element el) {
                  if (ro != null) return;
                  if (el is RenderObjectElement) {
                    ro = el.renderObject;
                    return;
                  }
                  el.visitChildren(findRenderObject);
                }

                findRenderObject(obj);
              }

              // Extract text content from the render tree (only actual rendered text)
              try {
                textContent = _extractTextFromRenderObject(ro);

                // If no direct text, collect ALL text from element subtree
                if (textContent == null) {
                  final allTexts = _collectAllTextInSubtree(obj);
                  if (allTexts.isNotEmpty) {
                    textContent = allTexts.join(' | ');
                  }
                }
              } catch (_) {
                // Text extraction can fail during navigation transitions
              }

              if (ro != null && ro is RenderBox) {
                final box = ro as RenderBox;
                if (box.hasSize) {
                  try {
                    final topLeft = box.localToGlobal(Offset.zero);
                    bounds = CombinedRect(
                      x: topLeft.dx,
                      y: topLeft.dy,
                      width: box.size.width,
                      height: box.size.height,
                    );
                  } catch (_) {}
                }
              }
            }
          } catch (e) {
            debugPrint('FlutterMate: toObject failed for $valueId: $e');
          }
        }

        // Process children FIRST - they claim their text and semantics
        // Collect all text claimed by descendants (for THIS node's deduplication only)
        final childRefs = <String>[];
        final childStartRef = refCounter;
        final descendantClaims = <String>{};

        for (final childJson in childrenJson) {
          if (childJson is Map<String, dynamic>) {
            final beforeCount = refCounter;
            final childClaims = walkInspectorNode(childJson, depth + 1);
            descendantClaims.addAll(childClaims);
            if (refCounter > beforeCount) {
              childRefs.add('w$beforeCount');
            }
          }
        }

        // This node's own claims (text it displays that wasn't claimed by children)
        final myClaims = <String>{};

        // NOW deduplicate text - only against MY children's claims, not siblings'
        if (textContent != null && textContent.isNotEmpty) {
          final texts = textContent.split(' | ');
          final newTexts = <String>[];
          for (final t in texts) {
            final key = normalizeText(t);
            if (key.isNotEmpty && !descendantClaims.contains(key)) {
              myClaims.add(key); // Claim this text
              newTexts.add(t);
            }
          }
          textContent = newTexts.isEmpty ? null : newTexts.join(' | ');
        }

        // NOW extract semantics - children have already claimed theirs
        if (ro != null) {
          final sn = _findSemanticsInRenderTree(ro!);
          if (sn != null && !usedSemanticsIds.contains(sn.id)) {
            usedSemanticsIds.add(sn.id);
            var sem = _extractSemanticsInfo(sn);

            // Also deduplicate semantics.label against MY children's claims only
            if (sem.label != null) {
              final labelKey = normalizeText(sem.label!);
              if (labelKey.isNotEmpty && descendantClaims.contains(labelKey)) {
                // Label was claimed by a child - clear it
                sem = SemanticsInfo(
                  id: sem.id,
                  identifier: sem.identifier,
                  label: null,
                  value: sem.value,
                  hint: sem.hint,
                  tooltip: sem.tooltip,
                  increasedValue: sem.increasedValue,
                  decreasedValue: sem.decreasedValue,
                  textDirection: sem.textDirection,
                  textSelectionBase: sem.textSelectionBase,
                  textSelectionExtent: sem.textSelectionExtent,
                  maxValueLength: sem.maxValueLength,
                  currentValueLength: sem.currentValueLength,
                  headingLevel: sem.headingLevel,
                  linkUrl: sem.linkUrl,
                  role: sem.role,
                  inputType: sem.inputType,
                  validationResult: sem.validationResult,
                  platformViewId: sem.platformViewId,
                  controlsNodes: sem.controlsNodes,
                  flags: sem.flags,
                  actions: sem.actions,
                  scrollChildCount: sem.scrollChildCount,
                  scrollIndex: sem.scrollIndex,
                  scrollPosition: sem.scrollPosition,
                  scrollExtentMax: sem.scrollExtentMax,
                  scrollExtentMin: sem.scrollExtentMin,
                );
              } else if (labelKey.isNotEmpty) {
                myClaims.add(labelKey); // Claim this label
              }
            }
            semantics = sem;
          }
        }

        // Insert this node at the correct position (before its children)
        final nodeIndex = nodes.length - (refCounter - childStartRef);
        nodes.insert(
          nodeIndex < 0 ? 0 : nodeIndex,
          CombinedNode(
            ref: ref,
            widget: widgetType,
            depth: depth,
            bounds: bounds,
            children: childRefs,
            semantics: semantics,
            textContent: textContent,
          ),
        );

        // Return all claims from this subtree (my claims + descendants' claims)
        return myClaims..addAll(descendantClaims);
      }

      walkInspectorNode(treeJson, 0);

      // Reorder nodes to be in depth-first order (parents before children)
      nodes.sort((a, b) {
        final refA = int.parse(a.ref.substring(1));
        final refB = int.parse(b.ref.substring(1));
        return refA.compareTo(refB);
      });

      // Apply filters (fromRef, depth, and compact mode)
      // All filtering is applied AFTER the walk to keep refs stable
      List<CombinedNode> filteredNodes = nodes;

      // Track the base depth for relative depth calculations
      int baseDepth = 0;

      // Apply fromRef filter - keep only the subtree rooted at fromRef
      if (fromRef != null) {
        // Find all descendants of fromRef
        final descendantRefs = <String>{fromRef};
        final nodeMap = {for (final n in nodes) n.ref: n};

        // Check if fromRef exists
        if (!nodeMap.containsKey(fromRef)) {
          return CombinedSnapshot(
            success: false,
            error: 'Element not found: $fromRef',
            timestamp: DateTime.now(),
            nodes: [],
          );
        }

        // Get the base depth from the root node
        baseDepth = nodeMap[fromRef]!.depth;

        // BFS to find all descendants
        final queue = [fromRef];
        while (queue.isNotEmpty) {
          final current = queue.removeAt(0);
          final node = nodeMap[current];
          if (node != null) {
            for (final childRef in node.children) {
              if (!descendantRefs.contains(childRef)) {
                descendantRefs.add(childRef);
                queue.add(childRef);
              }
            }
          }
        }

        filteredNodes =
            filteredNodes.where((n) => descendantRefs.contains(n.ref)).toList();
      }

      // Apply depth filter (if specified)
      // When using fromRef, depth is relative to the subtree root
      // e.g., --from w19 --depth 1 shows w19 and its direct children
      if (maxDepth != null) {
        final absoluteMaxDepth = baseDepth + maxDepth;
        filteredNodes =
            filteredNodes.where((n) => n.depth <= absoluteMaxDepth).toList();
      }

      // Apply compact filter (keep meaningful nodes + their ancestors)
      if (compact) {
        // Find all meaningful nodes
        final meaningfulRefs = <String>{};
        for (final node in filteredNodes) {
          if (node.hasAdditionalInfo) {
            meaningfulRefs.add(node.ref);
          }
        }

        // Build parent map (child -> parent)
        final parentMap = <String, String>{};
        for (final node in filteredNodes) {
          for (final childRef in node.children) {
            parentMap[childRef] = node.ref;
          }
        }

        // For each meaningful node, add all ancestors to keep set
        final keepRefs = <String>{...meaningfulRefs};
        for (final ref in meaningfulRefs) {
          var current = ref;
          while (parentMap.containsKey(current)) {
            final parent = parentMap[current]!;
            keepRefs.add(parent);
            current = parent;
          }
        }

        // Filter but keep ancestors (preserves tree structure)
        filteredNodes =
            filteredNodes.where((n) => keepRefs.contains(n.ref)).toList();
      }

      final snapshot = CombinedSnapshot(
        success: true,
        timestamp: DateTime.now(),
        nodes: filteredNodes,
      );

      // Cache full snapshot for ref -> semantics ID translation in actions
      // (even in compact mode, we need full data for interactions)
      FlutterMate.lastSnapshot = CombinedSnapshot(
        success: true,
        timestamp: DateTime.now(),
        nodes: nodes,
      );

      return snapshot;
    } catch (e, stack) {
      debugPrint('FlutterMate: snapshot error: $e\n$stack');
      return CombinedSnapshot(
        success: false,
        error: 'Failed to get snapshot: $e',
        timestamp: DateTime.now(),
        nodes: [],
      );
    }
  }

  /// Extract widget type from inspector description
  static String _extractWidgetType(String description) {
    // Description can be like "Text" or "Padding(padding: EdgeInsets...)"
    final parenIndex = description.indexOf('(');
    if (parenIndex > 0) {
      return description.substring(0, parenIndex);
    }
    return description;
  }

  /// Extract text content from a RenderObject using the render tree.
  ///
  /// This extracts ONLY actually rendered text by checking:
  /// - RenderParagraph: The render object for Text/RichText widgets
  /// - RenderEditable: The render object for TextField content
  ///
  /// This is more accurate than diagnostics-based extraction because it
  /// only returns text that is actually painted to screen.
  static String? _extractTextFromRenderObject(RenderObject? ro) {
    if (ro == null) return null;

    try {
      // RenderParagraph is what paints Text/RichText widgets
      if (ro is RenderParagraph) {
        final text = _extractTextFromSpan(ro.text);
        if (text.isNotEmpty) return text;
      }

      // RenderEditable is what paints TextField/TextFormField content
      if (ro is RenderEditable) {
        final text = ro.text?.toPlainText();
        if (text != null && text.trim().isNotEmpty) {
          return text.trim();
        }
      }
    } catch (_) {
      // Render object may be in invalid state
    }
    return null;
  }

  /// Extract plain text from an InlineSpan tree (TextSpan, WidgetSpan, etc.)
  static String _extractTextFromSpan(InlineSpan span) {
    final buffer = StringBuffer();

    void visit(InlineSpan s) {
      if (s is TextSpan) {
        if (s.text != null) {
          buffer.write(s.text);
        }
        s.children?.forEach(visit);
      }
      // WidgetSpan and other spans don't have extractable text
    }

    visit(span);
    return buffer.toString().trim();
  }

  /// Find semantics in the render tree, searching down if needed
  /// This finds semantics in internal widgets (like _InkResponse inside ElevatedButton)
  /// that are not in the inspector tree. Already-used IDs are skipped by the caller.
  static SemanticsNode? _findSemanticsInRenderTree(RenderObject ro) {
    // First check if this render object has direct semantics
    SemanticsNode? best = ro.debugSemantics;

    // If no direct semantics or it has no meaningful content, search children
    if (best == null || !_hasMeaningfulSemantics(best)) {
      void visitRenderObject(RenderObject child) {
        if (best != null && _hasMeaningfulSemantics(best!)) return;
        final sn = child.debugSemantics;
        if (sn != null && _hasMeaningfulSemantics(sn)) {
          best = sn;
          return;
        }
        child.visitChildren(visitRenderObject);
      }

      ro.visitChildren(visitRenderObject);
    }

    return best;
  }

  /// Check if a semantics node has meaningful content (actions, label, or value)
  static bool _hasMeaningfulSemantics(SemanticsNode node) {
    final data = node.getSemanticsData();
    return data.actions != 0 || data.label.isNotEmpty || data.value.isNotEmpty;
  }

  /// Cache of RenderObjects whose parent marks them as offstage
  /// Key: child RenderObject, Value: true if offstage
  static final Map<RenderObject, bool> _offstageStatusCache = {};

  /// Cache of parent -> children diagnostics to avoid repeated calls
  /// This is the expensive call we want to minimize
  static final Map<RenderObject, Map<RenderObject, bool>>
      _parentChildOffstageMap = {};

  /// Check if an element is offstage (not being painted)
  ///
  /// Uses two-level caching:
  /// 1. Direct cache: O(1) lookup for previously checked RenderObjects
  /// 2. Parent cache: Reuses parent's children diagnostics for siblings
  ///
  /// This detects widgets from previous routes, Offstage widgets, etc.
  static bool _isElementOffstage(Element element) {
    try {
      // Get the render object directly if available
      RenderObject? ro;
      if (element is RenderObjectElement) {
        ro = element.renderObject;
      }

      // No render object = can't determine, assume onstage
      if (ro == null) return false;

      // Check if unattached
      if (!ro.attached) return true;

      // Fast path: check direct cache (O(1))
      if (_offstageStatusCache.containsKey(ro)) {
        return _offstageStatusCache[ro]!;
      }

      // Check if any ancestor is cached as offstage
      RenderObject? current = ro.parent;
      while (current != null) {
        if (_offstageStatusCache[current] == true) {
          _offstageStatusCache[ro] = true;
          return true;
        }
        current = current.parent;
      }

      // Check parent's children diagnostics (cached per parent)
      final parent = ro.parent;
      if (parent != null) {
        // Get or build the parent's child offstage map
        if (!_parentChildOffstageMap.containsKey(parent)) {
          final childMap = <RenderObject, bool>{};
          try {
            // This is the expensive call - but only once per unique parent
            final children = parent.debugDescribeChildren();
            for (final child in children) {
              if (child.value is RenderObject) {
                childMap[child.value as RenderObject] =
                    child.style == DiagnosticsTreeStyle.offstage;
              }
            }
          } catch (_) {}
          _parentChildOffstageMap[parent] = childMap;
        }

        // Check if this child is marked offstage by its parent
        final isOffstage = _parentChildOffstageMap[parent]?[ro] ?? false;
        _offstageStatusCache[ro] = isOffstage;
        return isOffstage;
      }

      // No parent = root, not offstage
      _offstageStatusCache[ro] = false;
      return false;
    } catch (_) {
      // If we can't determine, assume it's onstage
      return false;
    }
  }

  /// Collect ALL text content from an element subtree using the render tree.
  /// Returns all text found, not just the first.
  /// Only extracts actually rendered text (RenderParagraph, RenderEditable).
  static List<String> _collectAllTextInSubtree(Element element) {
    final texts = <String>[];
    final seen = <String>{}; // Avoid duplicates

    void visit(Element child) {
      try {
        // Skip offstage elements (previous routes, Offstage widgets, etc.)
        if (_isElementOffstage(child)) {
          return;
        }

        // Try to extract text from the render object (not widget diagnostics)
        if (child is RenderObjectElement) {
          final content = _extractTextFromRenderObject(child.renderObject);
          if (content != null &&
              content.isNotEmpty &&
              !seen.contains(content)) {
            seen.add(content);
            texts.add(content);
          }
        }

        // Continue to ALL children (don't stop on first find)
        child.visitChildren(visit);
      } catch (_) {
        // Element may become invalid during navigation - skip it
      }
    }

    try {
      element.visitChildren(visit);
    } catch (_) {
      // Parent element may be invalid
    }
    return texts;
  }

  /// Extract semantics info from a SemanticsNode
  /// Includes all fields from SemanticsData for completeness.
  static SemanticsInfo _extractSemanticsInfo(SemanticsNode node) {
    final data = node.getSemanticsData();

    // Extract text selection if present
    int? textSelectionBase;
    int? textSelectionExtent;
    if (data.textSelection != null) {
      textSelectionBase = data.textSelection!.baseOffset;
      textSelectionExtent = data.textSelection!.extentOffset;
    }

    return SemanticsInfo(
      id: node.id,
      identifier: data.identifier.isNotEmpty ? data.identifier : null,
      label: data.label.isNotEmpty ? data.label : null,
      value: data.value.isNotEmpty ? data.value : null,
      hint: data.hint.isNotEmpty ? data.hint : null,
      tooltip: data.tooltip.isNotEmpty ? data.tooltip : null,
      increasedValue:
          data.increasedValue.isNotEmpty ? data.increasedValue : null,
      decreasedValue:
          data.decreasedValue.isNotEmpty ? data.decreasedValue : null,
      flags: getFlagsFromData(data).toSet(),
      actions: getActionsFromData(data).toSet(),
      // Text direction
      textDirection: data.textDirection?.name,
      // Text selection
      textSelectionBase: textSelectionBase,
      textSelectionExtent: textSelectionExtent,
      // Value length (for text fields)
      maxValueLength: data.maxValueLength,
      currentValueLength: data.currentValueLength,
      // Scroll properties
      scrollChildCount: data.scrollChildCount,
      scrollIndex: data.scrollIndex,
      scrollPosition: data.scrollPosition,
      scrollExtentMax: data.scrollExtentMax,
      scrollExtentMin: data.scrollExtentMin,
      // Additional properties
      headingLevel: data.headingLevel > 0 ? data.headingLevel : null,
      linkUrl: data.linkUrl?.toString(),
      role: data.role.name != 'none' ? data.role.name : null,
      inputType: data.inputType.name != 'none' ? data.inputType.name : null,
      validationResult: data.validationResult.name != 'none'
          ? data.validationResult.name
          : null,
      platformViewId: data.platformViewId != -1 ? data.platformViewId : null,
      controlsNodes: data.controlsNodes,
    );
  }
}

// ════════════════════════════════════════════════════════════════════════════
// Source: package:flutter_mate/src/actions/semantic_actions.dart
// ════════════════════════════════════════════════════════════════════════════

/// Semantics-based actions
///
/// These use Flutter's accessibility system to interact with elements.
/// Most reliable way to interact with standard Flutter widgets.
class SemanticActions {
  /// Tap on an element by ref
  ///
  /// Tries semantic tap action first (for Semantics widgets).
  /// Falls back to gesture-based tap if semantic action not available.
  ///
  /// ```dart
  /// await SemanticActions.tap('w5');
  /// ```
  static Future<bool> tap(String ref) async {
    FlutterMate.ensureInitialized();

    // Check if this ref has semantic tap action
    final lastSnapshot = FlutterMate.lastSnapshot;
    if (lastSnapshot != null) {
      final node = lastSnapshot[ref];
      if (node?.semantics?.hasAction('tap') == true) {
        debugPrint('FlutterMate: tap via semantic action on $ref');
        return _performAction(ref, SemanticsAction.tap);
      }
    }

    // Fallback to gesture-based tap
    debugPrint('FlutterMate: tap via gesture on $ref');
    return GestureActions.tapGesture(ref);
  }

  /// Long press on an element by ref
  ///
  /// Tries semantic longPress action first (for Semantics widgets).
  /// Falls back to gesture-based long press if semantic action not available.
  ///
  /// ```dart
  /// await SemanticActions.longPress('w5');
  /// ```
  static Future<bool> longPress(String ref) async {
    FlutterMate.ensureInitialized();

    // Check if this ref has semantic longPress action
    final lastSnapshot = FlutterMate.lastSnapshot;
    if (lastSnapshot != null) {
      final node = lastSnapshot[ref];
      if (node?.semantics?.hasAction('longPress') == true) {
        debugPrint('FlutterMate: longPress via semantic action on $ref');
        return _performAction(ref, SemanticsAction.longPress);
      }
    }

    // Fallback to gesture-based long press
    debugPrint('FlutterMate: longPress via gesture on $ref');
    return GestureActions.longPressGesture(ref);
  }

  /// Set text on an element using semantic setText action
  ///
  /// This is the semantic way to set text fields. For keyboard simulation,
  /// use [KeyboardActions.typeText] instead.
  ///
  /// ```dart
  /// await SemanticActions.setText('w9', 'hello@example.com');
  /// ```
  static Future<bool> setText(String ref, String text) async {
    FlutterMate.ensureInitialized();

    final node = findSemanticsNode(ref);
    if (node == null) {
      debugPrint('FlutterMate: setText - Node not found: $ref');
      return false;
    }

    final data = node.getSemanticsData();

    // Try to focus first
    if (data.hasAction(SemanticsAction.focus)) {
      node.owner?.performAction(node.id, SemanticsAction.focus);
      await FlutterMate.delay(const Duration(milliseconds: 50));
    }

    // Try setText even if not advertised - it often works anyway!
    // TextField may handle it internally even without advertising
    node.owner?.performAction(node.id, SemanticsAction.setText, text);
    await FlutterMate.delay(const Duration(milliseconds: 100));

    return true;
  }

  /// Scroll an element
  ///
  /// First tries semantic scroll action on the node or its ancestors.
  /// Falls back to gesture-based scrolling if no semantic scroll is available.
  ///
  /// ```dart
  /// await SemanticActions.scroll('w10', ScrollDirection.down);
  /// ```
  static Future<bool> scroll(String ref, ScrollDirection direction,
      {double distance = 200}) async {
    // NOTE: SemanticsAction scroll directions refer to VIEW movement, not content:
    // - scrollUp = view moves up = content moves down = reveals content BELOW
    // - scrollDown = view moves down = content moves up = reveals content ABOVE
    //
    // When user says "scroll down" they mean "see content below", so we use scrollUp
    final action = switch (direction) {
      ScrollDirection.up => SemanticsAction.scrollDown, // see content above
      ScrollDirection.down => SemanticsAction.scrollUp, // see content below
      ScrollDirection.left => SemanticsAction.scrollRight,
      ScrollDirection.right => SemanticsAction.scrollLeft,
    };

    // Find the node
    final node = findSemanticsNode(ref);
    if (node == null) {
      debugPrint('FlutterMate: Scroll - Node not found: $ref');
      return false;
    }

    // Tier 1: Try semantic scrolling first
    // Walk up the tree to find a scrollable ancestor
    SemanticsNode? current = node;
    while (current != null) {
      final data = current.getSemanticsData();
      if (data.hasAction(action)) {
        debugPrint('FlutterMate: Scroll via semantic action on w${current.id}');
        current.owner?.performAction(current.id, action);
        await FlutterMate.delay(const Duration(milliseconds: 300));
        return true;
      }
      current = current.parent;
    }

    // Tier 2: Fall back to gesture-based scrolling
    debugPrint('FlutterMate: No semantic scroll available, using gesture');
    return GestureActions.scrollGestureByDirection(ref, direction, distance);
  }

  /// Focus on an element by ref
  static Future<bool> focus(String ref) async {
    return _performAction(ref, SemanticsAction.focus);
  }

  // === Private helper methods ===

  static Future<bool> _performAction(String ref, SemanticsAction action) async {
    FlutterMate.ensureInitialized();

    final node = findSemanticsNode(ref);
    if (node == null) {
      debugPrint('FlutterMate: Node not found: $ref');
      return false;
    }

    final data = node.getSemanticsData();
    if (!data.hasAction(action)) {
      debugPrint('FlutterMate: Node $ref does not support $action');
      return false;
    }

    node.owner?.performAction(node.id, action);
    await FlutterMate.delay(const Duration(milliseconds: 100));

    return true;
  }
}

/// Tap element by label (convenience method)
Future<bool> tapByLabel(String label) async {
  final ref = await findByLabel(label);
  if (ref == null) {
    debugPrint('FlutterMate: tapByLabel - No element found with label: $label');
    return false;
  }
  return SemanticActions.tap(ref);
}

/// Fill text field by label (convenience method)
Future<bool> fillByLabel(String label, String text) async {
  final ref = await findByLabel(label);
  if (ref == null) {
    debugPrint(
        'FlutterMate: fillByLabel - No element found with label: $label');
    return false;
  }
  return SemanticActions.setText(ref, text);
}

/// Long press element by label (convenience method)
Future<bool> longPressByLabel(String label) async {
  final ref = await findByLabel(label);
  if (ref == null) {
    debugPrint(
        'FlutterMate: longPressByLabel - No element found with label: $label');
    return false;
  }
  return SemanticActions.longPress(ref);
}

/// Focus element by label (convenience method)
Future<bool> focusByLabel(String label) async {
  final ref = await findByLabel(label);
  if (ref == null) {
    debugPrint(
        'FlutterMate: focusByLabel - No element found with label: $label');
    return false;
  }
  return SemanticActions.focus(ref);
}

// ════════════════════════════════════════════════════════════════════════════
// Source: package:flutter_mate/src/actions/gesture_actions.dart
// ════════════════════════════════════════════════════════════════════════════

/// Gesture simulation actions
///
/// These inject raw pointer events to simulate touches and drags.
/// Use when you need precise control over gesture timing and position.
class GestureActions {
  static int _pointerIdCounter = 0;

  /// Double tap on an element by ref
  ///
  /// Uses gesture simulation to trigger GestureDetector.onDoubleTap callbacks.
  static Future<bool> doubleTap(String ref) async {
    return doubleTapGesture(ref);
  }

  /// Double tap via gesture simulation
  static Future<bool> doubleTapGesture(String ref) async {
    FlutterMate.ensureInitialized();

    final snap = await SnapshotService.snapshot();
    final nodeInfo = snap[ref];
    if (nodeInfo == null) {
      debugPrint('FlutterMate: Node not found: $ref');
      return false;
    }

    final centerPoint = nodeInfo.center;
    if (centerPoint == null) {
      debugPrint('FlutterMate: Node has no bounds: $ref');
      return false;
    }

    await doubleTapAt(Offset(centerPoint.x, centerPoint.y));
    return true;
  }

  /// Simulate a double tap at specific coordinates
  static Future<void> doubleTapAt(Offset position) async {
    FlutterMate.ensureInitialized();

    debugPrint('FlutterMate: doubleTapAt $position');

    // First tap
    await tapAt(position);
    // Short delay between taps (must be <300ms for double tap recognition)
    await FlutterMate.delay(const Duration(milliseconds: 100));
    // Second tap
    await tapAt(position);

    await FlutterMate.delay(const Duration(milliseconds: 50));
  }

  /// Internal gesture-based tap
  static Future<bool> tapGesture(String ref) async {
    final element = FlutterMate.cachedElements[ref];
    if (element == null) {
      debugPrint('FlutterMate: tapGesture - Element not found: $ref');
      return false;
    }

    RenderObject? ro = element.renderObject;
    while (ro != null && ro is! RenderBox) {
      if (ro is RenderObjectElement) {
        ro = (ro as RenderObjectElement).renderObject;
      } else {
        break;
      }
    }

    if (ro == null || ro is! RenderBox || !ro.hasSize) {
      debugPrint('FlutterMate: tapGesture - No RenderBox for: $ref');
      return false;
    }

    final box = ro;
    final center = box.localToGlobal(box.size.center(Offset.zero));
    await tapAt(center);
    return true;
  }

  /// Long press via gesture simulation
  static Future<bool> longPressGesture(String ref) async {
    FlutterMate.ensureInitialized();

    final snap = await SnapshotService.snapshot();
    final nodeInfo = snap[ref];
    if (nodeInfo == null) {
      debugPrint('FlutterMate: Node not found: $ref');
      return false;
    }

    // Calculate center of element
    final centerPoint = nodeInfo.center;
    if (centerPoint == null) {
      debugPrint('FlutterMate: Node has no bounds: $ref');
      return false;
    }

    await longPressAt(Offset(centerPoint.x, centerPoint.y));
    return true;
  }

  /// Scroll using gesture simulation, staying within element bounds
  static Future<bool> scrollGestureByDirection(
      String ref, ScrollDirection direction, double distance) async {
    FlutterMate.ensureInitialized();

    // Find the semantics node directly (not through snapshot which is slow)
    final node = findSemanticsNode(ref);
    if (node == null) {
      debugPrint(
          'FlutterMate: scrollGestureByDirection - Node not found: $ref');
      return false;
    }

    // Get the node's rect in global coordinates
    final localRect = node.rect;
    final transform = node.transform;

    Offset topLeft = localRect.topLeft;
    Offset bottomRight = localRect.bottomRight;
    if (transform != null) {
      topLeft = MatrixUtils.transformPoint(transform, localRect.topLeft);
      bottomRight =
          MatrixUtils.transformPoint(transform, localRect.bottomRight);
    }

    final centerX = (topLeft.dx + bottomRight.dx) / 2;
    final topY = topLeft.dy + (bottomRight.dy - topLeft.dy) * 0.25;
    final bottomY = topLeft.dy + (bottomRight.dy - topLeft.dy) * 0.75;

    // User direction refers to content they want to see:
    // - "scroll down" = see content below = drag finger UP (bottom to top)
    // - "scroll up" = see content above = drag finger DOWN (top to bottom)
    final (Offset from, Offset to) = switch (direction) {
      ScrollDirection.down =>
        // See content below: swipe up (drag from bottom to top)
        (Offset(centerX, bottomY), Offset(centerX, topY)),
      ScrollDirection.up =>
        // See content above: swipe down (drag from top to bottom)
        (Offset(centerX, topY), Offset(centerX, bottomY)),
      ScrollDirection.left => () {
          // See content on left: swipe right
          final leftX = topLeft.dx + (bottomRight.dx - topLeft.dx) * 0.25;
          final rightX = topLeft.dx + (bottomRight.dx - topLeft.dx) * 0.75;
          final centerY = (topLeft.dy + bottomRight.dy) / 2;
          return (Offset(leftX, centerY), Offset(rightX, centerY));
        }(),
      ScrollDirection.right => () {
          // See content on right: swipe left
          final leftX = topLeft.dx + (bottomRight.dx - topLeft.dx) * 0.25;
          final rightX = topLeft.dx + (bottomRight.dx - topLeft.dx) * 0.75;
          final centerY = (topLeft.dy + bottomRight.dy) / 2;
          return (Offset(rightX, centerY), Offset(leftX, centerY));
        }(),
    };

    debugPrint('FlutterMate: scrollGesture $direction from $from to $to');

    await drag(from: from, to: to);

    return true;
  }

  /// Simulate a tap at screen coordinates
  ///
  /// This sends real pointer events, mimicking actual user touch.
  /// ```dart
  /// await GestureActions.tapAt(Offset(100, 200));
  /// ```
  static Future<void> tapAt(Offset position) async {
    FlutterMate.ensureInitialized();

    final pointerId = ++_pointerIdCounter;
    final now = Duration(milliseconds: DateTime.now().millisecondsSinceEpoch);

    // Pointer down
    FlutterMate.dispatchPointerEvent(PointerDownEvent(
      pointer: pointerId,
      position: position,
      timeStamp: now,
    ));

    await FlutterMate.delay(const Duration(milliseconds: 50));

    // Pointer up
    FlutterMate.dispatchPointerEvent(PointerUpEvent(
      pointer: pointerId,
      position: position,
      timeStamp: now + const Duration(milliseconds: 50),
    ));

    await FlutterMate.delay(const Duration(milliseconds: 50));
  }

  /// Simulate a drag/swipe gesture
  ///
  /// ```dart
  /// await GestureActions.drag(
  ///   from: Offset(200, 500),
  ///   to: Offset(200, 200),
  ///   duration: Duration(milliseconds: 300),
  /// );
  /// ```
  static Future<void> drag({
    required Offset from,
    required Offset to,
    Duration duration = const Duration(milliseconds: 200),
    int steps = 10,
  }) async {
    FlutterMate.ensureInitialized();

    final pointerId = ++_pointerIdCounter;
    final startTime =
        Duration(milliseconds: DateTime.now().millisecondsSinceEpoch);
    final stepDuration = duration ~/ steps;
    final totalDelta = to - from;
    final stepDelta = totalDelta / steps.toDouble();

    debugPrint('FlutterMate: drag from $from to $to');

    // Pointer down at start - use touch device kind for scrolling
    FlutterMate.dispatchPointerEvent(PointerDownEvent(
      pointer: pointerId,
      position: from,
      timeStamp: startTime,
      kind: PointerDeviceKind.touch,
    ));

    await FlutterMate.delay(const Duration(milliseconds: 16));

    // Move through intermediate points with acceleration
    var currentPosition = from;
    for (var i = 1; i <= steps; i++) {
      currentPosition = from + stepDelta * i.toDouble();

      FlutterMate.dispatchPointerEvent(PointerMoveEvent(
        pointer: pointerId,
        position: currentPosition,
        delta: stepDelta,
        timeStamp: startTime + stepDuration * i,
        kind: PointerDeviceKind.touch,
      ));

      await FlutterMate.delay(const Duration(milliseconds: 8));
    }

    // Quick final moves to add velocity
    for (var i = 0; i < 3; i++) {
      currentPosition = currentPosition + stepDelta * 0.5;
      FlutterMate.dispatchPointerEvent(PointerMoveEvent(
        pointer: pointerId,
        position: currentPosition,
        delta: stepDelta * 0.5,
        timeStamp: startTime + duration + Duration(milliseconds: i * 8),
        kind: PointerDeviceKind.touch,
      ));
      await FlutterMate.delay(const Duration(milliseconds: 8));
    }

    // Pointer up at end
    FlutterMate.dispatchPointerEvent(PointerUpEvent(
      pointer: pointerId,
      position: currentPosition,
      timeStamp: startTime + duration + const Duration(milliseconds: 50),
      kind: PointerDeviceKind.touch,
    ));

    // Wait for scroll physics to settle
    await FlutterMate.delay(const Duration(milliseconds: 300));
  }

  /// Simulate a scroll gesture on an element
  ///
  /// ```dart
  /// await GestureActions.scrollGesture('w15', Offset(0, -200));
  /// ```
  static Future<bool> scrollGesture(String ref, Offset delta) async {
    FlutterMate.ensureInitialized();

    final snap = await SnapshotService.snapshot();
    final node = snap[ref];
    if (node == null) {
      debugPrint('FlutterMate: scrollGesture - Node not found: $ref');
      return false;
    }

    final centerPoint = node.center;
    if (centerPoint == null) {
      debugPrint('FlutterMate: scrollGesture - Node has no bounds: $ref');
      return false;
    }

    final center = Offset(centerPoint.x, centerPoint.y);
    debugPrint(
        'FlutterMate: scrollGesture from $center delta $delta (to ${center + delta})');

    await drag(
      from: center,
      to: center + delta,
      duration: const Duration(milliseconds: 300),
    );

    // Wait for scroll physics to settle
    await FlutterMate.delay(const Duration(milliseconds: 100));

    return true;
  }

  /// Simulate a hover (mouse enter) over an element by ref
  ///
  /// Sends PointerHoverEvent to trigger onHover/onEnter callbacks.
  /// ```dart
  /// await GestureActions.hover('w15');
  /// ```
  static Future<bool> hover(String ref) async {
    FlutterMate.ensureInitialized();

    final snap = await SnapshotService.snapshot();
    final nodeInfo = snap[ref];
    if (nodeInfo == null) {
      debugPrint('FlutterMate: Node not found: $ref');
      return false;
    }

    final centerPoint = nodeInfo.center;
    if (centerPoint == null) {
      debugPrint('FlutterMate: Node has no bounds: $ref');
      return false;
    }

    await hoverAt(Offset(centerPoint.x, centerPoint.y));
    return true;
  }

  /// Simulate a hover at specific coordinates
  ///
  /// Sends mouse enter and hover events to trigger hover callbacks.
  static Future<void> hoverAt(Offset position) async {
    FlutterMate.ensureInitialized();

    debugPrint('FlutterMate: hoverAt $position');

    final pointerId = ++_pointerIdCounter;
    final now = Duration(milliseconds: DateTime.now().millisecondsSinceEpoch);

    // Send hover event (mouse device kind required for hover)
    FlutterMate.dispatchPointerEvent(PointerHoverEvent(
      pointer: pointerId,
      position: position,
      timeStamp: now,
      kind: PointerDeviceKind.mouse,
    ));

    await FlutterMate.delay(const Duration(milliseconds: 100));
  }

  /// Move mouse to position (for hover effects)
  static Future<void> mouseMoveTo(Offset position) async {
    FlutterMate.ensureInitialized();

    final now = Duration(milliseconds: DateTime.now().millisecondsSinceEpoch);

    FlutterMate.dispatchPointerEvent(PointerHoverEvent(
      position: position,
      timeStamp: now,
      kind: PointerDeviceKind.mouse,
    ));

    await FlutterMate.delay(const Duration(milliseconds: 16));
  }

  /// Drag from one element to another
  ///
  /// ```dart
  /// await GestureActions.dragFromTo('w10', 'w20');
  /// ```
  static Future<bool> dragFromTo(String fromRef, String toRef) async {
    FlutterMate.ensureInitialized();

    final snap = await SnapshotService.snapshot();
    final fromNode = snap[fromRef];
    final toNode = snap[toRef];

    if (fromNode == null) {
      debugPrint('FlutterMate: From node not found: $fromRef');
      return false;
    }
    if (toNode == null) {
      debugPrint('FlutterMate: To node not found: $toRef');
      return false;
    }

    final fromCenter = fromNode.center;
    final toCenter = toNode.center;
    if (fromCenter == null || toCenter == null) {
      debugPrint('FlutterMate: Nodes have no bounds');
      return false;
    }

    await drag(
      from: Offset(fromCenter.x, fromCenter.y),
      to: Offset(toCenter.x, toCenter.y),
    );
    return true;
  }

  /// Simulate a long press at screen coordinates
  static Future<void> longPressAt(
    Offset position, {
    Duration pressDuration = const Duration(milliseconds: 600),
  }) async {
    FlutterMate.ensureInitialized();

    debugPrint('FlutterMate: longPressAt $position');

    final pointerId = ++_pointerIdCounter;
    final now = Duration(milliseconds: DateTime.now().millisecondsSinceEpoch);

    // Pointer down - use touch for gesture recognition
    FlutterMate.dispatchPointerEvent(PointerDownEvent(
      pointer: pointerId,
      position: position,
      timeStamp: now,
      kind: PointerDeviceKind.touch,
    ));

    // Hold for long press duration (must be >500ms for recognition)
    await FlutterMate.delay(pressDuration);

    // Pointer up
    FlutterMate.dispatchPointerEvent(PointerUpEvent(
      pointer: pointerId,
      position: position,
      timeStamp: now + pressDuration,
    ));

    await FlutterMate.delay(const Duration(milliseconds: 50));
  }

  /// Swipe gesture from a starting position in a direction
  ///
  /// [direction] - 'up', 'down', 'left', or 'right'
  /// [startX], [startY] - Starting position
  /// [distance] - Distance to swipe in pixels
  static Future<bool> swipe({
    required String direction,
    double startX = 200,
    double startY = 400,
    double distance = 200,
  }) async {
    FlutterMate.ensureInitialized();

    double endX = startX, endY = startY;
    switch (direction.toLowerCase()) {
      case 'up':
        endY = startY - distance;
      case 'down':
        endY = startY + distance;
      case 'left':
        endX = startX - distance;
      case 'right':
        endX = startX + distance;
      default:
        debugPrint('FlutterMate: Invalid swipe direction: $direction');
        return false;
    }

    await drag(
      from: Offset(startX, startY),
      to: Offset(endX, endY),
      duration: const Duration(milliseconds: 200),
    );

    return true;
  }
}

/// Double tap element by label (convenience method)
Future<bool> doubleTapByLabel(String label) async {
  final ref = await findByLabel(label);
  if (ref == null) {
    debugPrint(
        'FlutterMate: doubleTapByLabel - No element found with label: $label');
    return false;
  }
  return GestureActions.doubleTap(ref);
}

// ════════════════════════════════════════════════════════════════════════════
// Source: package:flutter_mate/src/actions/keyboard_actions.dart
// ════════════════════════════════════════════════════════════════════════════

/// Keyboard / text input simulation
///
/// Uses platform messages to simulate keyboard input, just like a real keyboard.
///
/// How it works:
/// 1. typeText(ref, text) finds the widget from the inspector tree
/// 2. Taps to focus the TextField
/// 3. Sends platform messages with magic client ID -1 (debug builds only)
/// 4. Falls back to EditableTextState in release builds
///
/// Usage:
///   await FlutterMate.snapshot();  // Cache elements
///   await KeyboardActions.typeText('w10', 'hello@example.com');
class KeyboardActions {
  /// Type text into a text field by ref
  ///
  /// In debug builds, uses platform message simulation with magic client ID -1.
  /// In release builds, falls back to EditableTextState.updateEditingValue().
  ///
  /// ```dart
  /// await KeyboardActions.typeText('w10', 'hello@example.com');
  /// ```
  static Future<bool> typeText(String ref, String text) async {
    FlutterMate.ensureInitialized();

    debugPrint('FlutterMate: typeText "$text" into $ref');

    try {
      // Find the Element from cached inspector tree
      final element = FlutterMate.cachedElements[ref];
      if (element == null) {
        debugPrint(
            'FlutterMate: Element not found for $ref. Did you call snapshot() first?');
        return false;
      }

      // Find the center of the element for tapping
      RenderObject? ro;
      if (element is RenderObjectElement) {
        ro = element.renderObject;
      } else {
        // Walk down to find RenderObject
        void findRenderObject(Element el) {
          if (ro != null) return;
          if (el is RenderObjectElement) {
            ro = el.renderObject;
            return;
          }
          el.visitChildren(findRenderObject);
        }

        findRenderObject(element);
      }

      if (ro == null || ro is! RenderBox) {
        debugPrint('FlutterMate: No RenderBox found for $ref');
        return false;
      }

      final box = ro as RenderBox;
      if (!box.hasSize) {
        debugPrint('FlutterMate: RenderBox has no size for $ref');
        return false;
      }

      // Calculate center and tap to focus
      final center = box.localToGlobal(Offset.zero) +
          Offset(box.size.width / 2, box.size.height / 2);
      debugPrint('FlutterMate: Tapping to focus at $center');
      await GestureActions.tapAt(center);

      // Wait for focus and text input connection to be established
      await FlutterMate.delay(const Duration(milliseconds: 150));

      // Get current text from the focused field
      final focusNode = FocusManager.instance.primaryFocus;
      String currentText = '';
      if (focusNode != null) {
        final editableState = _findEditableTextState(focusNode.context);
        if (editableState != null) {
          currentText = editableState.currentTextEditingValue.text;
        }
      }

      // In debug builds, use platform messages with magic client ID -1
      // In release builds, magic ID won't work - use EditableTextState fallback
      bool isDebugMode = false;
      assert(() {
        isDebugMode = true;
        return true;
      }());

      if (isDebugMode) {
        // Type character by character using platform messages
        for (int i = 0; i < text.length; i++) {
          currentText += text[i];
          await FlutterMate.dispatchTextInput(currentText);
        }
        debugPrint('FlutterMate: Typed "$text" via platform messages');
        return true;
      } else {
        // Release mode: fall back to EditableTextState
        debugPrint(
            'FlutterMate: Release mode - using EditableTextState fallback');
        return _typeTextViaEditableState(text);
      }
    } catch (e, stack) {
      debugPrint('FlutterMate: typeText error: $e\n$stack');
      return false;
    }
  }

  /// Type text into the currently focused field (fallback method)
  static Future<bool> _typeTextViaEditableState(String text) async {
    final focusNode = FocusManager.instance.primaryFocus;
    if (focusNode == null) {
      debugPrint('FlutterMate: No focused element');
      return false;
    }

    final editableState = _findEditableTextState(focusNode.context);
    if (editableState == null) {
      debugPrint('FlutterMate: No EditableTextState found');
      return false;
    }

    String currentText = editableState.currentTextEditingValue.text;

    for (int i = 0; i < text.length; i++) {
      currentText += text[i];
      editableState.updateEditingValue(TextEditingValue(
        text: currentText,
        selection: TextSelection.collapsed(offset: currentText.length),
      ));
      if (!FlutterMate.isTestMode) {
        await Future.delayed(const Duration(milliseconds: 20));
      }
    }

    debugPrint('FlutterMate: Typed "$text" via EditableTextState (fallback)');
    return true;
  }

  /// Find EditableTextState from a BuildContext
  static EditableTextState? _findEditableTextState(BuildContext? context) {
    if (context == null) return null;

    EditableTextState? found;

    // Search subtree first
    void visitor(Element element) {
      if (found != null) return;
      if (element is StatefulElement && element.state is EditableTextState) {
        found = element.state as EditableTextState;
        return;
      }
      element.visitChildren(visitor);
    }

    (context as Element).visitChildren(visitor);

    // If not in subtree, check ancestors
    if (found == null) {
      context.visitAncestorElements((element) {
        if (element is StatefulElement && element.state is EditableTextState) {
          found = element.state as EditableTextState;
          return false;
        }
        return true;
      });
    }

    return found;
  }

  /// Clear the currently focused text field
  static Future<bool> clearText() async {
    FlutterMate.ensureInitialized();

    debugPrint('FlutterMate: clearText');

    try {
      final focusNode = FocusManager.instance.primaryFocus;
      if (focusNode == null) {
        debugPrint('FlutterMate: No focused element');
        return false;
      }

      final editableState = _findEditableTextState(focusNode.context);
      if (editableState == null) {
        debugPrint('FlutterMate: No EditableTextState found');
        return false;
      }

      // Use updateEditingValue to clear - same as platform input
      editableState.updateEditingValue(const TextEditingValue(
        text: '',
        selection: TextSelection.collapsed(offset: 0),
      ));
      debugPrint('FlutterMate: Text cleared');
      return true;
    } catch (e) {
      debugPrint('FlutterMate: clearText error: $e');
      return false;
    }
  }

  /// Simulate pressing a specific key (keydown + keyup)
  ///
  /// ```dart
  /// await KeyboardActions.pressKey(LogicalKeyboardKey.enter);
  /// await KeyboardActions.pressKey(LogicalKeyboardKey.tab);
  /// ```
  static Future<bool> pressKey(LogicalKeyboardKey key) async {
    FlutterMate.ensureInitialized();

    try {
      await keyDown(key);
      await FlutterMate.delay(const Duration(milliseconds: 30));
      await keyUp(key);
      await FlutterMate.delay(const Duration(milliseconds: 30));

      return true;
    } catch (e) {
      debugPrint('FlutterMate: pressKey error: $e');
      return false;
    }
  }

  /// Simulate pressing a key down (without releasing)
  ///
  /// Use with [keyUp] for fine-grained keyboard control.
  /// ```dart
  /// await KeyboardActions.keyDown(LogicalKeyboardKey.shift);
  /// await KeyboardActions.pressKey(LogicalKeyboardKey.keyA);
  /// await KeyboardActions.keyUp(LogicalKeyboardKey.shift);
  /// ```
  static Future<bool> keyDown(
    LogicalKeyboardKey key, {
    bool control = false,
    bool shift = false,
    bool alt = false,
    bool command = false,
  }) async {
    FlutterMate.ensureInitialized();

    try {
      final messenger = WidgetsBinding.instance.defaultBinaryMessenger;
      final keyId = key.keyId;
      final modifiers = _getModifiers(
        control: control,
        shift: shift,
        alt: alt,
        command: command,
      );

      await _sendKeyEventWithLogicalKey(messenger, 'keydown', keyId, modifiers);
      return true;
    } catch (e) {
      debugPrint('FlutterMate: keyDown error: $e');
      return false;
    }
  }

  /// Simulate releasing a key (after keyDown)
  ///
  /// ```dart
  /// await KeyboardActions.keyDown(LogicalKeyboardKey.shift);
  /// await KeyboardActions.pressKey(LogicalKeyboardKey.keyA);
  /// await KeyboardActions.keyUp(LogicalKeyboardKey.shift);
  /// ```
  static Future<bool> keyUp(
    LogicalKeyboardKey key, {
    bool control = false,
    bool shift = false,
    bool alt = false,
    bool command = false,
  }) async {
    FlutterMate.ensureInitialized();

    try {
      final messenger = WidgetsBinding.instance.defaultBinaryMessenger;
      final keyId = key.keyId;
      final modifiers = _getModifiers(
        control: control,
        shift: shift,
        alt: alt,
        command: command,
      );

      await _sendKeyEventWithLogicalKey(messenger, 'keyup', keyId, modifiers);
      return true;
    } catch (e) {
      debugPrint('FlutterMate: keyUp error: $e');
      return false;
    }
  }

  /// Get macOS modifier flags for keyboard events
  static int _getModifiers({
    bool control = false,
    bool shift = false,
    bool alt = false,
    bool command = false,
  }) {
    int modifiers = 0;
    if (shift) modifiers |= 0x20000;
    if (control) modifiers |= 0x40000;
    if (alt) modifiers |= 0x80000;
    if (command) modifiers |= 0x100000;
    return modifiers;
  }

  static Future<void> _sendKeyEventWithLogicalKey(
    BinaryMessenger messenger,
    String type,
    int logicalKeyId,
    int modifiers,
  ) async {
    final message = const JSONMessageCodec().encodeMessage(<String, dynamic>{
      'type': type,
      'keymap': 'macos',
      'keyCode': logicalKeyId & 0xFFFF,
      'modifiers': modifiers,
    });

    if (message != null) {
      await messenger.send('flutter/keyevent', message);
    }
  }

  /// Simulate pressing Enter key
  static Future<bool> pressEnter() => pressKey(LogicalKeyboardKey.enter);

  /// Simulate pressing Tab key
  static Future<bool> pressTab() => pressKey(LogicalKeyboardKey.tab);

  /// Simulate pressing Escape key
  static Future<bool> pressEscape() => pressKey(LogicalKeyboardKey.escape);

  /// Simulate pressing Backspace key
  static Future<bool> pressBackspace() =>
      pressKey(LogicalKeyboardKey.backspace);

  /// Simulate pressing arrow keys
  static Future<bool> pressArrowUp() => pressKey(LogicalKeyboardKey.arrowUp);
  static Future<bool> pressArrowDown() =>
      pressKey(LogicalKeyboardKey.arrowDown);
  static Future<bool> pressArrowLeft() =>
      pressKey(LogicalKeyboardKey.arrowLeft);
  static Future<bool> pressArrowRight() =>
      pressKey(LogicalKeyboardKey.arrowRight);

  /// Simulate keyboard shortcut (e.g., Cmd+A, Ctrl+C)
  ///
  /// ```dart
  /// await KeyboardActions.pressShortcut(LogicalKeyboardKey.keyA, command: true);  // Cmd+A
  /// await KeyboardActions.pressShortcut(LogicalKeyboardKey.keyC, control: true);  // Ctrl+C
  /// ```
  static Future<bool> pressShortcut(
    LogicalKeyboardKey key, {
    bool control = false,
    bool shift = false,
    bool alt = false,
    bool command = false,
  }) async {
    FlutterMate.ensureInitialized();

    try {
      await keyDown(key,
          control: control, shift: shift, alt: alt, command: command);
      await FlutterMate.delay(const Duration(milliseconds: 30));
      await keyUp(key,
          control: control, shift: shift, alt: alt, command: command);
      await FlutterMate.delay(const Duration(milliseconds: 30));

      return true;
    } catch (e) {
      debugPrint('FlutterMate: pressShortcut error: $e');
      return false;
    }
  }

  /// Parse a key name string to LogicalKeyboardKey
  static LogicalKeyboardKey? parseLogicalKey(String key) {
    return switch (key.toLowerCase()) {
      'enter' => LogicalKeyboardKey.enter,
      'tab' => LogicalKeyboardKey.tab,
      'escape' => LogicalKeyboardKey.escape,
      'backspace' => LogicalKeyboardKey.backspace,
      'delete' => LogicalKeyboardKey.delete,
      'space' => LogicalKeyboardKey.space,
      'arrowup' => LogicalKeyboardKey.arrowUp,
      'arrowdown' => LogicalKeyboardKey.arrowDown,
      'arrowleft' => LogicalKeyboardKey.arrowLeft,
      'arrowright' => LogicalKeyboardKey.arrowRight,
      _ => null,
    };
  }
}

// ════════════════════════════════════════════════════════════════════════════
// Source: package:flutter_mate/src/core/service_extensions.dart
// ════════════════════════════════════════════════════════════════════════════

/// VM Service extensions for external control via CLI/MCP.
///
/// Registers `ext.flutter_mate.*` service extensions that allow external
/// tools to control Flutter apps through the Dart VM Service Protocol.
///
/// ## Available Extensions
///
/// **Snapshot:**
/// - `ext.flutter_mate.snapshot` - Get UI tree with widget refs and semantics
/// - `ext.flutter_mate.find` - Get detailed info about a specific element
///
/// **Ref-based actions (use widget ref from snapshot):**
/// - `ext.flutter_mate.tap` - Tap element (semantic + gesture fallback)
/// - `ext.flutter_mate.setText` - Set text via semantic action
/// - `ext.flutter_mate.scroll` - Scroll element in a direction
/// - `ext.flutter_mate.focus` - Focus element
/// - `ext.flutter_mate.longPress` - Long press element
/// - `ext.flutter_mate.doubleTap` - Double tap element
/// - `ext.flutter_mate.typeText` - Type text via keyboard simulation
/// - `ext.flutter_mate.hover` - Hover over element (triggers onHover)
/// - `ext.flutter_mate.drag` - Drag from one element to another
///
/// **Coordinate-based actions:**
/// - `ext.flutter_mate.tapAt` - Tap at screen coordinates
/// - `ext.flutter_mate.doubleTapAt` - Double tap at coordinates
/// - `ext.flutter_mate.longPressAt` - Long press at coordinates
/// - `ext.flutter_mate.hoverAt` - Hover at coordinates
/// - `ext.flutter_mate.dragTo` - Drag from one point to another
/// - `ext.flutter_mate.swipe` - Swipe gesture from a start position
///
/// **Keyboard:**
/// - `ext.flutter_mate.pressKey` - Press a keyboard key (keydown + keyup)
/// - `ext.flutter_mate.keyDown` - Press key down (without releasing)
/// - `ext.flutter_mate.keyUp` - Release a key
/// - `ext.flutter_mate.clearText` - Clear focused text field
///
/// **Utilities:**
/// - `ext.flutter_mate.ensureSemantics` - Enable semantics tree
class FlutterMateServiceExtensions {
  static bool _registered = false;

  /// Register all service extensions
  static void register() {
    // Only register once (extensions persist across test runs in same VM)
    if (_registered) return;

    // Only register in debug/profile mode
    assert(() {
      // ext.flutter_mate.tap - Tap element by ref
      registerExtension('ext.flutter_mate.tap', (method, params) async {
        final ref = params['ref'];
        if (ref == null) {
          return ServiceExtensionResponse.error(
            ServiceExtensionResponse.invalidParams,
            'Missing ref parameter',
          );
        }
        final success = await SemanticActions.tap(ref);
        if (!success) {
          return ServiceExtensionResponse.result(jsonEncode({
            'success': false,
            'error': 'tap failed: element may not support tap action',
          }));
        }
        return ServiceExtensionResponse.result(jsonEncode({'success': true}));
      });

      // ext.flutter_mate.setText - Set text on element (semantic action)
      registerExtension('ext.flutter_mate.setText', (method, params) async {
        final ref = params['ref'];
        final text = params['text'];
        if (ref == null || text == null) {
          return ServiceExtensionResponse.error(
            ServiceExtensionResponse.invalidParams,
            'Missing ref or text parameter',
          );
        }
        final success = await SemanticActions.setText(ref, text);
        if (!success) {
          return ServiceExtensionResponse.result(jsonEncode({
            'success': false,
            'error': 'setText failed: element may not support setText action',
          }));
        }
        return ServiceExtensionResponse.result(jsonEncode({'success': true}));
      });

      // ext.flutter_mate.scroll - Scroll element
      registerExtension('ext.flutter_mate.scroll', (method, params) async {
        final ref = params['ref'];
        final dirStr = params['direction'] ?? 'down';
        final distanceStr = params['distance'];
        final distance =
            distanceStr != null ? double.tryParse(distanceStr) ?? 300.0 : 300.0;
        if (ref == null) {
          return ServiceExtensionResponse.error(
            ServiceExtensionResponse.invalidParams,
            'Missing ref parameter',
          );
        }
        final direction = switch (dirStr) {
          'up' => ScrollDirection.up,
          'left' => ScrollDirection.left,
          'right' => ScrollDirection.right,
          _ => ScrollDirection.down,
        };
        final success =
            await SemanticActions.scroll(ref, direction, distance: distance);
        if (!success) {
          return ServiceExtensionResponse.result(jsonEncode({
            'success': false,
            'error': 'scroll failed: element may not support scroll action',
          }));
        }
        return ServiceExtensionResponse.result(jsonEncode({'success': true}));
      });

      // ext.flutter_mate.focus - Focus element
      registerExtension('ext.flutter_mate.focus', (method, params) async {
        final ref = params['ref'];
        if (ref == null) {
          return ServiceExtensionResponse.error(
            ServiceExtensionResponse.invalidParams,
            'Missing ref parameter',
          );
        }
        final success = await SemanticActions.focus(ref);
        if (!success) {
          return ServiceExtensionResponse.result(jsonEncode({
            'success': false,
            'error': 'focus failed: element may not support focus action',
          }));
        }
        return ServiceExtensionResponse.result(jsonEncode({'success': true}));
      });

      // ext.flutter_mate.snapshot - Get UI snapshot (widget tree + semantics)
      // Options:
      //   compact=true - filter to only nodes with meaningful info
      //   depth=N - limit tree depth
      //   fromRef=wX - start from specific element as root
      registerExtension('ext.flutter_mate.snapshot', (method, params) async {
        final compact = params['compact'] == 'true';
        final depthStr = params['depth'];
        final maxDepth = depthStr != null ? int.tryParse(depthStr) : null;
        final fromRef = params['fromRef'];

        final snap = await SnapshotService.snapshot(
          compact: compact,
          maxDepth: maxDepth,
          fromRef: fromRef,
        );
        return ServiceExtensionResponse.result(jsonEncode(snap.toJson()));
      });

      // ext.flutter_mate.longPress - Long press element by ref
      registerExtension('ext.flutter_mate.longPress', (method, params) async {
        final ref = params['ref'];
        if (ref == null) {
          return ServiceExtensionResponse.error(
            ServiceExtensionResponse.invalidParams,
            'Missing ref parameter',
          );
        }
        final success = await SemanticActions.longPress(ref);
        if (!success) {
          return ServiceExtensionResponse.result(jsonEncode({
            'success': false,
            'error': 'longPress failed: element not found or no bounds',
          }));
        }
        return ServiceExtensionResponse.result(jsonEncode({'success': true}));
      });

      // ext.flutter_mate.doubleTap - Double tap element by ref
      registerExtension('ext.flutter_mate.doubleTap', (method, params) async {
        final ref = params['ref'];
        if (ref == null) {
          return ServiceExtensionResponse.error(
            ServiceExtensionResponse.invalidParams,
            'Missing ref parameter',
          );
        }
        final success = await GestureActions.doubleTap(ref);
        if (!success) {
          return ServiceExtensionResponse.result(jsonEncode({
            'success': false,
            'error': 'doubleTap failed: element not found or no bounds',
          }));
        }
        return ServiceExtensionResponse.result(jsonEncode({'success': true}));
      });

      // ext.flutter_mate.typeText - Type text into a text field by ref
      registerExtension('ext.flutter_mate.typeText', (method, params) async {
        final ref = params['ref'];
        final text = params['text'];
        if (ref == null || text == null) {
          return ServiceExtensionResponse.error(
            ServiceExtensionResponse.invalidParams,
            'Missing ref or text parameter',
          );
        }
        final success = await KeyboardActions.typeText(ref, text);
        if (!success) {
          return ServiceExtensionResponse.result(jsonEncode({
            'success': false,
            'error': 'typeText failed: element not found or not a text field',
          }));
        }
        return ServiceExtensionResponse.result(jsonEncode({'success': true}));
      });

      // ext.flutter_mate.clearText - Clear focused text field
      registerExtension('ext.flutter_mate.clearText', (method, params) async {
        final success = await KeyboardActions.clearText();
        return ServiceExtensionResponse.result(
            jsonEncode({'success': success}));
      });

      // ext.flutter_mate.pressKey - Press a keyboard key
      registerExtension('ext.flutter_mate.pressKey', (method, params) async {
        final key = params['key'];
        if (key == null) {
          return ServiceExtensionResponse.error(
            ServiceExtensionResponse.invalidParams,
            'Missing key parameter',
          );
        }
        final logicalKey = KeyboardActions.parseLogicalKey(key);
        if (logicalKey == null) {
          return ServiceExtensionResponse.error(
            ServiceExtensionResponse.invalidParams,
            'Unknown key: $key',
          );
        }
        final success = await KeyboardActions.pressKey(logicalKey);
        return ServiceExtensionResponse.result(
            jsonEncode({'success': success}));
      });

      // ext.flutter_mate.ensureSemantics - Ensure semantics tree is available
      registerExtension('ext.flutter_mate.ensureSemantics',
          (method, params) async {
        try {
          WidgetsBinding.instance.ensureSemantics();
          return ServiceExtensionResponse.result(jsonEncode({'success': true}));
        } catch (e) {
          return ServiceExtensionResponse.result(
              jsonEncode({'success': false, 'error': e.toString()}));
        }
      });

      // ext.flutter_mate.tapAt - Tap at screen coordinates
      registerExtension('ext.flutter_mate.tapAt', (method, params) async {
        final x = double.tryParse(params['x'] ?? '');
        final y = double.tryParse(params['y'] ?? '');
        if (x == null || y == null) {
          return ServiceExtensionResponse.error(
            ServiceExtensionResponse.invalidParams,
            'Missing or invalid x/y coordinates',
          );
        }
        await GestureActions.tapAt(Offset(x, y));
        return ServiceExtensionResponse.result(jsonEncode({'success': true}));
      });

      // ext.flutter_mate.doubleTapAt - Double tap at screen coordinates
      registerExtension('ext.flutter_mate.doubleTapAt', (method, params) async {
        final x = double.tryParse(params['x'] ?? '');
        final y = double.tryParse(params['y'] ?? '');
        if (x == null || y == null) {
          return ServiceExtensionResponse.error(
            ServiceExtensionResponse.invalidParams,
            'Missing or invalid x/y coordinates',
          );
        }
        await GestureActions.doubleTapAt(Offset(x, y));
        return ServiceExtensionResponse.result(jsonEncode({'success': true}));
      });

      // ext.flutter_mate.longPressAt - Long press at screen coordinates
      registerExtension('ext.flutter_mate.longPressAt', (method, params) async {
        final x = double.tryParse(params['x'] ?? '');
        final y = double.tryParse(params['y'] ?? '');
        final durationMs = int.tryParse(params['durationMs'] ?? '500') ?? 500;
        if (x == null || y == null) {
          return ServiceExtensionResponse.error(
            ServiceExtensionResponse.invalidParams,
            'Missing or invalid x/y coordinates',
          );
        }
        await GestureActions.longPressAt(Offset(x, y),
            pressDuration: Duration(milliseconds: durationMs));
        return ServiceExtensionResponse.result(jsonEncode({'success': true}));
      });

      // ext.flutter_mate.swipe - Swipe gesture
      registerExtension('ext.flutter_mate.swipe', (method, params) async {
        final direction = params['direction'] ?? 'up';
        final startX = double.tryParse(params['startX'] ?? '200') ?? 200;
        final startY = double.tryParse(params['startY'] ?? '400') ?? 400;
        final distance = double.tryParse(params['distance'] ?? '200') ?? 200;

        final success = await GestureActions.swipe(
          direction: direction,
          startX: startX,
          startY: startY,
          distance: distance,
        );
        return ServiceExtensionResponse.result(
            jsonEncode({'success': success}));
      });

      // ext.flutter_mate.hover - Hover over element by ref
      registerExtension('ext.flutter_mate.hover', (method, params) async {
        final ref = params['ref'];
        if (ref == null) {
          return ServiceExtensionResponse.error(
            ServiceExtensionResponse.invalidParams,
            'Missing ref parameter',
          );
        }
        final success = await GestureActions.hover(ref);
        if (!success) {
          return ServiceExtensionResponse.result(jsonEncode({
            'success': false,
            'error': 'hover failed: element not found or no bounds',
          }));
        }
        return ServiceExtensionResponse.result(jsonEncode({'success': true}));
      });

      // ext.flutter_mate.hoverAt - Hover at screen coordinates
      registerExtension('ext.flutter_mate.hoverAt', (method, params) async {
        final x = double.tryParse(params['x'] ?? '');
        final y = double.tryParse(params['y'] ?? '');
        if (x == null || y == null) {
          return ServiceExtensionResponse.error(
            ServiceExtensionResponse.invalidParams,
            'Missing or invalid x/y coordinates',
          );
        }
        await GestureActions.hoverAt(Offset(x, y));
        return ServiceExtensionResponse.result(jsonEncode({'success': true}));
      });

      // ext.flutter_mate.drag - Drag from one element to another by refs
      registerExtension('ext.flutter_mate.drag', (method, params) async {
        final fromRef = params['fromRef'];
        final toRef = params['toRef'];
        if (fromRef == null || toRef == null) {
          return ServiceExtensionResponse.error(
            ServiceExtensionResponse.invalidParams,
            'Missing fromRef or toRef parameter',
          );
        }
        final success = await GestureActions.dragFromTo(fromRef, toRef);
        if (!success) {
          return ServiceExtensionResponse.result(jsonEncode({
            'success': false,
            'error': 'drag failed: element not found or no bounds',
          }));
        }
        return ServiceExtensionResponse.result(jsonEncode({'success': true}));
      });

      // ext.flutter_mate.dragTo - Drag from one point to another
      registerExtension('ext.flutter_mate.dragTo', (method, params) async {
        final fromX = double.tryParse(params['fromX'] ?? '');
        final fromY = double.tryParse(params['fromY'] ?? '');
        final toX = double.tryParse(params['toX'] ?? '');
        final toY = double.tryParse(params['toY'] ?? '');
        if (fromX == null || fromY == null || toX == null || toY == null) {
          return ServiceExtensionResponse.error(
            ServiceExtensionResponse.invalidParams,
            'Missing or invalid coordinates',
          );
        }
        await GestureActions.drag(
          from: Offset(fromX, fromY),
          to: Offset(toX, toY),
        );
        return ServiceExtensionResponse.result(jsonEncode({'success': true}));
      });

      // ext.flutter_mate.keyDown - Press key down (without releasing)
      registerExtension('ext.flutter_mate.keyDown', (method, params) async {
        final key = params['key'];
        if (key == null) {
          return ServiceExtensionResponse.error(
            ServiceExtensionResponse.invalidParams,
            'Missing key parameter',
          );
        }
        final logicalKey = KeyboardActions.parseLogicalKey(key);
        if (logicalKey == null) {
          return ServiceExtensionResponse.error(
            ServiceExtensionResponse.invalidParams,
            'Unknown key: $key',
          );
        }
        final control = params['control'] == 'true';
        final shift = params['shift'] == 'true';
        final alt = params['alt'] == 'true';
        final command = params['command'] == 'true';

        final success = await KeyboardActions.keyDown(logicalKey,
            control: control, shift: shift, alt: alt, command: command);
        return ServiceExtensionResponse.result(
            jsonEncode({'success': success}));
      });

      // ext.flutter_mate.keyUp - Release a key
      registerExtension('ext.flutter_mate.keyUp', (method, params) async {
        final key = params['key'];
        if (key == null) {
          return ServiceExtensionResponse.error(
            ServiceExtensionResponse.invalidParams,
            'Missing key parameter',
          );
        }
        final logicalKey = KeyboardActions.parseLogicalKey(key);
        if (logicalKey == null) {
          return ServiceExtensionResponse.error(
            ServiceExtensionResponse.invalidParams,
            'Unknown key: $key',
          );
        }
        final control = params['control'] == 'true';
        final shift = params['shift'] == 'true';
        final alt = params['alt'] == 'true';
        final command = params['command'] == 'true';

        final success = await KeyboardActions.keyUp(logicalKey,
            control: control, shift: shift, alt: alt, command: command);
        return ServiceExtensionResponse.result(
            jsonEncode({'success': success}));
      });

      // ext.flutter_mate.find - Get detailed info about a specific element
      registerExtension('ext.flutter_mate.find', (method, params) async {
        final ref = params['ref'];
        if (ref == null) {
          return ServiceExtensionResponse.error(
            ServiceExtensionResponse.invalidParams,
            'Missing ref parameter',
          );
        }

        final snap = await SnapshotService.snapshot();
        final node = snap[ref];
        if (node == null) {
          return ServiceExtensionResponse.result(jsonEncode({
            'success': false,
            'error': 'Element not found: $ref',
          }));
        }

        return ServiceExtensionResponse.result(jsonEncode({
          'success': true,
          'element': node.toJson(),
        }));
      });

      // ext.flutter_mate.screenshot - Capture screenshot of entire app
      registerExtension('ext.flutter_mate.screenshot', (method, params) async {
        final ref = params['ref'];
        final pixelRatio =
            double.tryParse(params['pixelRatio'] ?? '1.0') ?? 1.0;

        String? base64;
        if (ref != null && ref.isNotEmpty) {
          // Capture specific element
          base64 = await ScreenshotService.captureElementAsBase64(ref,
              pixelRatio: pixelRatio);
        } else {
          // Capture full screen
          base64 =
              await ScreenshotService.captureAsBase64(pixelRatio: pixelRatio);
        }

        if (base64 == null) {
          return ServiceExtensionResponse.result(jsonEncode({
            'success': false,
            'error': 'Screenshot capture failed',
          }));
        }

        return ServiceExtensionResponse.result(jsonEncode({
          'success': true,
          'image': base64,
          'format': 'png',
          'encoding': 'base64',
        }));
      });

      _registered = true;
      debugPrint('FlutterMate: Service extensions registered');
      return true;
    }());
  }
}

/// Scroll direction for scroll actions
enum ScrollDirection { up, down, left, right }

// ════════════════════════════════════════════════════════════════════════════
// Source: package:flutter_mate/src/actions.dart
// ════════════════════════════════════════════════════════════════════════════

/// Action definitions and executor for flutter_mate.
///
/// This module provides the translation layer between structured action commands
/// (from an AI agent, CLI, or MCP server) and the actual SDK execution.
///
/// ## Architecture
///
/// ```
/// ┌─────────────────────────────────────────────────────────────┐
/// │                     AGENT (LLM)                             │
/// │  Receives: snapshot, tool definitions                       │
/// │  Outputs: structured action JSON                            │
/// └─────────────────────────────────────────────────────────────┘
///                            │
///                            ▼
/// ┌─────────────────────────────────────────────────────────────┐
/// │                   ACTION SCHEMA                             │
/// │  [MateAction.toolDefinitions] - for LLM function calling    │
/// └─────────────────────────────────────────────────────────────┘
///                            │
///                            ▼
/// ┌─────────────────────────────────────────────────────────────┐
/// │                   STRUCTURED ACTION                         │
/// │  { "action": "tap", "ref": "w5" }                          │
/// │  { "action": "fill", "ref": "w10", "text": "hello" }       │
/// └─────────────────────────────────────────────────────────────┘
///                            │
///                            ▼
/// ┌─────────────────────────────────────────────────────────────┐
/// │                   ACTION EXECUTOR                           │
/// │  [ActionExecutor.execute] - calls FlutterMate SDK           │
/// └─────────────────────────────────────────────────────────────┘
/// ```
///
/// ## Usage
///
/// ```dart
/// // Get tool definitions for the LLM
/// final tools = MateAction.toolDefinitions;
///
/// // Execute an action from the agent
/// final result = await ActionExecutor.execute({
///   'action': 'tap',
///   'ref': 'w5',
/// });
/// ```

// ══════════════════════════════════════════════════════════════════════════════
// ACTION TYPES
// ══════════════════════════════════════════════════════════════════════════════

/// All available automation actions.
enum MateActionType {
  /// Take a snapshot of the current UI state.
  snapshot,

  /// Tap on an element by ref.
  tap,

  /// Tap at specific coordinates.
  tapAt,

  /// Fill a text field with text.
  fill,

  /// Clear a text field.
  clear,

  /// Scroll an element in a direction.
  scroll,

  /// Focus on an element.
  focus,

  /// Type text character by character (simulates keyboard input).
  typeText,

  /// Press a keyboard key.
  pressKey,

  /// Wait for a specified duration.
  wait,
}

// ══════════════════════════════════════════════════════════════════════════════
// TOOL DEFINITIONS (for LLM function calling / MCP)
// ══════════════════════════════════════════════════════════════════════════════

/// Tool definitions that can be passed to an LLM for function calling.
///
/// These follow the OpenAI/Anthropic function calling format and can be used
/// directly with MCP (Model Context Protocol).
class MateAction {
  MateAction._();

  /// Get all tool definitions for LLM function calling.
  ///
  /// Returns a list of tool definitions in the standard format that can be
  /// passed to OpenAI, Anthropic, or MCP-compatible systems.
  ///
  /// ```dart
  /// final tools = MateAction.toolDefinitions;
  /// // Pass to your LLM API
  /// ```
  static List<Map<String, dynamic>> get toolDefinitions => [
        snapshotTool,
        tapTool,
        tapAtTool,
        setTextTool,
        clearTool,
        scrollTool,
        focusTool,
        typeTextTool,
        pressKeyTool,
        waitTool,
      ];

  /// Snapshot tool - capture current UI state.
  static Map<String, dynamic> get snapshotTool => {
        'name': 'snapshot',
        'description': '''Capture the current UI state of the Flutter app.

Returns a structured representation of all visible elements with:
- ref: Unique identifier for interaction (e.g., "w5", "w10")
- widget: Widget type (e.g., "Text", "ElevatedButton", "TextField")
- bounds: Position and size {x, y, width, height}
- semantics: Accessibility info (label, value, actions, flags)

Use the ref to interact with elements via tap, fill, scroll, etc.

Example output:
```json
{
  "success": true,
  "nodes": [
    {"ref": "w5", "widget": "Text", "semantics": {"label": "Welcome"}},
    {"ref": "w10", "widget": "ElevatedButton", "semantics": {"label": "Sign In", "actions": ["tap"]}}
  ]
}
```''',
        'inputSchema': {
          'type': 'object',
          'properties': {},
        },
      };

  /// Tap tool - tap on an element.
  static Map<String, dynamic> get tapTool => {
        'name': 'tap',
        'description': '''Tap on a UI element by its ref.

Performs a tap gesture on the element, triggering onTap handlers, button presses, etc.

Use snapshot first to get element refs.

Example: tap(ref: "w10") to tap the Sign In button.''',
        'inputSchema': {
          'type': 'object',
          'properties': {
            'ref': {
              'type': 'string',
              'description':
                  'The element ref from snapshot (e.g., "w5", "w10").',
            },
          },
          'required': ['ref'],
        },
      };

  /// TapAt tool - tap at coordinates.
  static Map<String, dynamic> get tapAtTool => {
        'name': 'tapAt',
        'description': '''Tap at specific screen coordinates.

Use when you need to tap at a specific position, e.g., for custom gestures
or elements without refs.

Coordinates are in logical pixels from top-left of screen.''',
        'inputSchema': {
          'type': 'object',
          'properties': {
            'x': {
              'type': 'number',
              'description': 'X coordinate in logical pixels.',
            },
            'y': {
              'type': 'number',
              'description': 'Y coordinate in logical pixels.',
            },
          },
          'required': ['x', 'y'],
        },
      };

  /// SetText tool - set text via semantic action.
  static Map<String, dynamic> get setTextTool => {
        'name': 'setText',
        'description': '''Set text on a field via semantic action.

Use on Semantics widgets (look for semantics.actions containing "setText").
For keyboard simulation on TextField widgets, use typeText instead.

Example: setText(ref: "w9", text: "user@example.com")''',
        'inputSchema': {
          'type': 'object',
          'properties': {
            'ref': {
              'type': 'string',
              'description': 'The text field ref from snapshot.',
            },
            'text': {
              'type': 'string',
              'description': 'The text to enter.',
            },
          },
          'required': ['ref', 'text'],
        },
      };

  /// Clear tool - clear a text field.
  static Map<String, dynamic> get clearTool => {
        'name': 'clear',
        'description': '''Clear all text from a text field.

Removes all content from the specified text field.''',
        'inputSchema': {
          'type': 'object',
          'properties': {
            'ref': {
              'type': 'string',
              'description': 'The text field ref from snapshot.',
            },
          },
          'required': ['ref'],
        },
      };

  /// Scroll tool - scroll a scrollable.
  static Map<String, dynamic> get scrollTool => {
        'name': 'scroll',
        'description': '''Scroll a scrollable element.

Scrolls the specified element (ListView, SingleChildScrollView, etc.)
in the given direction.

Use to reveal off-screen content before interacting with it.''',
        'inputSchema': {
          'type': 'object',
          'properties': {
            'ref': {
              'type': 'string',
              'description': 'The scrollable element ref.',
            },
            'direction': {
              'type': 'string',
              'enum': ['up', 'down', 'left', 'right'],
              'description': 'Direction to scroll.',
            },
            'amount': {
              'type': 'number',
              'description':
                  'Distance to scroll in logical pixels. Default: 300.',
            },
          },
          'required': ['ref', 'direction'],
        },
      };

  /// Focus tool - focus on an element.
  static Map<String, dynamic> get focusTool => {
        'name': 'focus',
        'description': '''Focus on a form field or focusable element.

Gives keyboard focus to the element. Useful for text fields before typing.''',
        'inputSchema': {
          'type': 'object',
          'properties': {
            'ref': {
              'type': 'string',
              'description': 'The element ref to focus.',
            },
          },
          'required': ['ref'],
        },
      };

  /// TypeText tool - type text character by character.
  static Map<String, dynamic> get typeTextTool => {
        'name': 'typeText',
        'description': '''Type text into a widget using keyboard simulation.

Unlike setText() which uses semantic action, this uses platform message
simulation to type character by character like a real keyboard.

Use this for TextField widgets (e.g., w10). For Semantics widgets, use fill instead.''',
        'inputSchema': {
          'type': 'object',
          'properties': {
            'ref': {
              'type': 'string',
              'description':
                  'Widget ref to type into (e.g., w10 for TextField).',
            },
            'text': {
              'type': 'string',
              'description': 'The text to type.',
            },
          },
          'required': ['ref', 'text'],
        },
      };

  /// PressKey tool - press a keyboard key.
  static Map<String, dynamic> get pressKeyTool => {
        'name': 'pressKey',
        'description': '''Press a keyboard key.

Simulates pressing a keyboard key. Useful for:
- Navigation: "enter", "tab", "escape", "arrowUp", "arrowDown", "arrowLeft", "arrowRight"
- Editing: "backspace", "delete"
- Shortcuts: Use with modifiers for shortcuts

Common keys: enter, tab, escape, backspace, delete, 
arrowUp, arrowDown, arrowLeft, arrowRight''',
        'inputSchema': {
          'type': 'object',
          'properties': {
            'key': {
              'type': 'string',
              'description':
                  'The key to press (e.g., "enter", "tab", "escape").',
            },
          },
          'required': ['key'],
        },
      };

  /// Wait tool - pause execution.
  static Map<String, dynamic> get waitTool => {
        'name': 'wait',
        'description': '''Wait for a specified duration.

Pauses execution to allow animations, network requests, or state changes
to complete before the next action.

Use sparingly - prefer waiting for specific UI changes when possible.''',
        'inputSchema': {
          'type': 'object',
          'properties': {
            'milliseconds': {
              'type': 'integer',
              'description': 'Duration to wait in milliseconds.',
            },
          },
          'required': ['milliseconds'],
        },
      };
}

// ══════════════════════════════════════════════════════════════════════════════
// ACTION RESULT
// ══════════════════════════════════════════════════════════════════════════════

/// Result of executing an action.
class ActionResult {
  /// Whether the action succeeded.
  final bool success;

  /// Error message if the action failed.
  final String? error;

  /// Result data (varies by action type).
  final dynamic data;

  /// Timestamp when the action completed.
  final DateTime timestamp;

  const ActionResult({
    required this.success,
    this.error,
    this.data,
    required this.timestamp,
  });

  /// Create a successful result.
  factory ActionResult.ok([dynamic data]) => ActionResult(
        success: true,
        data: data,
        timestamp: DateTime.now(),
      );

  /// Create a failed result.
  factory ActionResult.fail(String error) => ActionResult(
        success: false,
        error: error,
        timestamp: DateTime.now(),
      );

  /// Convert to JSON for serialization.
  Map<String, dynamic> toJson() => {
        'success': success,
        if (error != null) 'error': error,
        if (data != null) 'data': data,
        'timestamp': timestamp.toIso8601String(),
      };

  @override
  String toString() => jsonEncode(toJson());
}

// ══════════════════════════════════════════════════════════════════════════════
// ACTION EXECUTOR
// ══════════════════════════════════════════════════════════════════════════════

/// Executes actions from structured JSON commands.
///
/// This is the translation layer between agent-generated commands and the
/// FlutterMate SDK.
///
/// ```dart
/// // Execute a single action
/// final result = await ActionExecutor.execute({
///   'action': 'tap',
///   'ref': 'w5',
/// });
///
/// // Execute a sequence of actions
/// final results = await ActionExecutor.executeSequence([
///   {'action': 'fill', 'ref': 'w10', 'text': 'hello@example.com'},
///   {'action': 'fill', 'ref': 'w15', 'text': 'password123'},
///   {'action': 'tap', 'ref': 'w20'},
/// ]);
/// ```
class ActionExecutor {
  ActionExecutor._();

  /// Execute a single action from a JSON command.
  ///
  /// The command should have an 'action' field specifying the action type,
  /// plus any required parameters for that action.
  ///
  /// Returns an [ActionResult] indicating success/failure and any data.
  static Future<ActionResult> execute(Map<String, dynamic> command) async {
    final actionName = command['action'] as String?;
    if (actionName == null) {
      return ActionResult.fail('Missing required field: action');
    }

    try {
      switch (actionName) {
        case 'snapshot':
          return await _executeSnapshot(command);
        case 'tap':
          return await _executeTap(command);
        case 'tapAt':
          return await _executeTapAt(command);
        case 'setText':
          return await _executeSetText(command);
        case 'clear':
          return await _executeClear(command);
        case 'scroll':
          return await _executeScroll(command);
        case 'focus':
          return await _executeFocus(command);
        case 'typeText':
          return await _executeTypeText(command);
        case 'pressKey':
          return await _executePressKey(command);
        case 'wait':
          return await _executeWait(command);
        default:
          return ActionResult.fail('Unknown action: $actionName');
      }
    } catch (e, stack) {
      return ActionResult.fail('Action failed: $e\n$stack');
    }
  }

  /// Execute a sequence of actions.
  ///
  /// Stops on first failure unless [continueOnError] is true.
  ///
  /// Returns a list of results, one per action.
  static Future<List<ActionResult>> executeSequence(
    List<Map<String, dynamic>> commands, {
    bool continueOnError = false,
  }) async {
    final results = <ActionResult>[];

    for (final command in commands) {
      final result = await execute(command);
      results.add(result);

      if (!result.success && !continueOnError) {
        break;
      }
    }

    return results;
  }

  // ──────────────────────────────────────────────────────────────────────────
  // Action Handlers
  // ──────────────────────────────────────────────────────────────────────────

  static Future<ActionResult> _executeSnapshot(
      Map<String, dynamic> command) async {
    final snapshot = await SnapshotService.snapshot();

    if (!snapshot.success) {
      return ActionResult.fail(snapshot.error ?? 'Snapshot failed');
    }

    return ActionResult.ok({
      'nodeCount': snapshot.nodes.length,
      'nodes': snapshot.nodes.map((n) => n.toJson()).toList(),
    });
  }

  static Future<ActionResult> _executeTap(Map<String, dynamic> command) async {
    final ref = command['ref'] as String?;
    if (ref == null) {
      return ActionResult.fail('Missing required field: ref');
    }

    final success = await SemanticActions.tap(ref);
    if (success) {
      return ActionResult.ok();
    } else {
      return ActionResult.fail('Failed to tap element: $ref');
    }
  }

  static Future<ActionResult> _executeTapAt(
      Map<String, dynamic> command) async {
    final x = (command['x'] as num?)?.toDouble();
    final y = (command['y'] as num?)?.toDouble();

    if (x == null || y == null) {
      return ActionResult.fail('Missing required fields: x, y');
    }

    await GestureActions.tapAt(Offset(x, y));
    return ActionResult.ok();
  }

  static Future<ActionResult> _executeSetText(
      Map<String, dynamic> command) async {
    final ref = command['ref'] as String?;
    final text = command['text'] as String?;

    if (ref == null) {
      return ActionResult.fail('Missing required field: ref');
    }
    if (text == null) {
      return ActionResult.fail('Missing required field: text');
    }

    final success = await SemanticActions.setText(ref, text);
    if (success) {
      return ActionResult.ok();
    } else {
      return ActionResult.fail('Failed to setText on element: $ref');
    }
  }

  static Future<ActionResult> _executeClear(
      Map<String, dynamic> command) async {
    // clearText() clears the currently focused text field
    // First focus the element if ref is provided
    final ref = command['ref'] as String?;
    if (ref != null) {
      final focused = await SemanticActions.focus(ref);
      if (!focused) {
        return ActionResult.fail('Failed to focus element: $ref');
      }
    }

    final success = await KeyboardActions.clearText();
    if (success) {
      return ActionResult.ok();
    } else {
      return ActionResult.fail('Failed to clear text field');
    }
  }

  static Future<ActionResult> _executeScroll(
      Map<String, dynamic> command) async {
    final ref = command['ref'] as String?;
    final directionStr = command['direction'] as String?;
    // Note: amount parameter is accepted but not used by current SDK
    // final amount = (command['amount'] as num?)?.toDouble() ?? 300.0;

    if (ref == null) {
      return ActionResult.fail('Missing required field: ref');
    }
    if (directionStr == null) {
      return ActionResult.fail('Missing required field: direction');
    }

    final direction = switch (directionStr.toLowerCase()) {
      'up' => ScrollDirection.up,
      'down' => ScrollDirection.down,
      'left' => ScrollDirection.left,
      'right' => ScrollDirection.right,
      _ => null,
    };

    if (direction == null) {
      return ActionResult.fail(
          'Invalid direction: $directionStr. Must be up, down, left, or right.');
    }

    final success = await SemanticActions.scroll(ref, direction);
    if (success) {
      return ActionResult.ok();
    } else {
      return ActionResult.fail('Failed to scroll element: $ref');
    }
  }

  static Future<ActionResult> _executeFocus(
      Map<String, dynamic> command) async {
    final ref = command['ref'] as String?;
    if (ref == null) {
      return ActionResult.fail('Missing required field: ref');
    }

    final success = await SemanticActions.focus(ref);
    if (success) {
      return ActionResult.ok();
    } else {
      return ActionResult.fail('Failed to focus element: $ref');
    }
  }

  static Future<ActionResult> _executeTypeText(
      Map<String, dynamic> command) async {
    final ref = command['ref'] as String?;
    final text = command['text'] as String?;
    if (ref == null) {
      return ActionResult.fail('Missing required field: ref');
    }
    if (text == null) {
      return ActionResult.fail('Missing required field: text');
    }

    final success = await KeyboardActions.typeText(ref, text);
    if (!success) {
      return ActionResult.fail('Failed to type text into $ref');
    }
    return ActionResult.ok();
  }

  static Future<ActionResult> _executePressKey(
      Map<String, dynamic> command) async {
    final key = command['key'] as String?;
    if (key == null) {
      return ActionResult.fail('Missing required field: key');
    }

    // Map common key names to SDK methods
    switch (key.toLowerCase()) {
      case 'enter':
        await KeyboardActions.pressEnter();
      case 'tab':
        await KeyboardActions.pressTab();
      case 'escape':
        await KeyboardActions.pressEscape();
      case 'backspace':
        await KeyboardActions.pressBackspace();
      case 'arrowup':
        await KeyboardActions.pressArrowUp();
      case 'arrowdown':
        await KeyboardActions.pressArrowDown();
      case 'arrowleft':
        await KeyboardActions.pressArrowLeft();
      case 'arrowright':
        await KeyboardActions.pressArrowRight();
      default:
        return ActionResult.fail('Unknown key: $key');
    }

    return ActionResult.ok();
  }

  static Future<ActionResult> _executeWait(Map<String, dynamic> command) async {
    final ms = command['milliseconds'] as int?;
    if (ms == null) {
      return ActionResult.fail('Missing required field: milliseconds');
    }

    await Future.delayed(Duration(milliseconds: ms));
    return ActionResult.ok();
  }
}

// ════════════════════════════════════════════════════════════════════════════
// Source: package:flutter_mate/src/protocol.dart
// ════════════════════════════════════════════════════════════════════════════

/// Flutter Mate Protocol - Command schemas for automation
///
/// Inspired by [agent-browser](https://github.com/vercel-labs/agent-browser)
/// protocol, adapted for Flutter's widget and semantics system.
///
/// ## Architecture
///
/// ```
/// ┌──────────────────────────────────────────────────────────────────┐
/// │                         AI AGENT (LLM)                           │
/// │  Receives: snapshot with refs, tool definitions                  │
/// │  Outputs: Command JSON matching this protocol                    │
/// └──────────────────────────────────────────────────────────────────┘
///                                │
///                                ▼
/// ┌──────────────────────────────────────────────────────────────────┐
///   Protocol (this file)                                            │
/// │  • Command schemas (tap, fill, scroll, etc.)                    │
/// │  • Response format (success/error)                              │
/// │  • Ref system (w0, w1, w2...)                                   │
/// └──────────────────────────────────────────────────────────────────┘
///                                │
///                                ▼
/// ┌──────────────────────────────────────────────────────────────────┐
/// │                     CommandExecutor                              │
/// │  Parses JSON → Validates → Executes via FlutterMate SDK        │
/// └──────────────────────────────────────────────────────────────────┘
/// ```
///
/// ## Ref System
///
/// Elements are identified by refs assigned during snapshot:
/// - `w0`, `w1`, `w2`... for widget tree nodes
/// - Refs are stable until the next snapshot
/// - Use `snapshot` to get current refs before interacting
///
/// ## Usage
///
/// ```dart
/// // Parse and validate a command
/// final result = Command.parse('{"action": "tap", "ref": "w5"}');
/// if (result.isValid) {
///   final response = await executor.execute(result.command!);
/// }
///
/// // Get tool definitions for LLM
/// final tools = Command.toolDefinitions;
/// ```

// ══════════════════════════════════════════════════════════════════════════════
// COMMAND TYPES
// ══════════════════════════════════════════════════════════════════════════════

/// All available command actions.
enum CommandAction {
  // ─────────────────────────────────────────────────────────────────────────
  // Connection
  // ─────────────────────────────────────────────────────────────────────────
  /// Attach to a running Flutter app via VM Service URI.
  attach,

  /// Disconnect from the Flutter app.
  disconnect,

  // ─────────────────────────────────────────────────────────────────────────
  // Inspection
  // ─────────────────────────────────────────────────────────────────────────
  /// Get UI snapshot with element refs.
  snapshot,

  /// Take a screenshot of the current screen.
  screenshot,

  /// Get text content of an element.
  getText,

  /// Check if an element is visible.
  isVisible,

  /// Check if an element is enabled.
  isEnabled,

  // ─────────────────────────────────────────────────────────────────────────
  // Interaction - Touch
  // ─────────────────────────────────────────────────────────────────────────
  /// Tap on an element.
  tap,

  /// Tap at specific coordinates.
  tapAt,

  /// Double tap on an element.
  doubleTap,

  /// Long press on an element.
  longPress,

  /// Drag from one element/position to another.
  drag,

  /// Swipe in a direction.
  swipe,

  /// Scroll a scrollable element.
  scroll,

  // ─────────────────────────────────────────────────────────────────────────
  // Interaction - Text Input
  // ─────────────────────────────────────────────────────────────────────────
  /// Set text on a field via semantic action.
  setText,

  /// Type text character by character via keyboard simulation.
  typeText,

  /// Clear a text field.
  clear,

  // ─────────────────────────────────────────────────────────────────────────
  // Interaction - Keyboard
  // ─────────────────────────────────────────────────────────────────────────
  /// Press a keyboard key.
  pressKey,

  // ─────────────────────────────────────────────────────────────────────────
  // Interaction - Form Controls
  // ─────────────────────────────────────────────────────────────────────────
  /// Focus on an element.
  focus,

  /// Toggle a switch or checkbox.
  toggle,

  /// Select an option from a dropdown.
  select,

  // ─────────────────────────────────────────────────────────────────────────
  // Navigation
  // ─────────────────────────────────────────────────────────────────────────
  /// Navigate to a named route.
  navigate,

  /// Go back (pop navigation).
  back,

  // ─────────────────────────────────────────────────────────────────────────
  // Utility
  // ─────────────────────────────────────────────────────────────────────────
  /// Wait for a condition or duration.
  wait,
}

// ══════════════════════════════════════════════════════════════════════════════
// COMMAND SCHEMAS
// ══════════════════════════════════════════════════════════════════════════════

/// Base command that all commands extend.
abstract class Command {
  /// Unique identifier for this command (for request/response correlation).
  final String? id;

  /// The action to perform.
  CommandAction get action;

  const Command({this.id});

  /// Convert to JSON map.
  Map<String, dynamic> toJson();

  /// Parse a JSON string or map into a Command.
  static ParseResult parse(dynamic input) {
    try {
      Map<String, dynamic> json;
      if (input is String) {
        json = jsonDecode(input) as Map<String, dynamic>;
      } else if (input is Map<String, dynamic>) {
        json = input;
      } else {
        return ParseResult.error('Invalid input type: ${input.runtimeType}');
      }

      final id = json['id'] as String?;
      final actionStr = json['action'] as String?;

      if (actionStr == null) {
        return ParseResult.error('Missing required field: action', id: id);
      }

      // Parse action
      final action = CommandAction.values.asNameByValue(actionStr);
      if (action == null) {
        return ParseResult.error('Unknown action: $actionStr', id: id);
      }

      // Delegate to specific command parser
      return _parseCommand(action, json, id);
    } catch (e) {
      return ParseResult.error('Parse error: $e');
    }
  }

  /// Get tool definitions for LLM function calling.
  static List<Map<String, dynamic>> get toolDefinitions => [
        SnapshotCommand.toolDefinition,
        TapCommand.toolDefinition,
        TapAtCommand.toolDefinition,
        DoubleTapCommand.toolDefinition,
        LongPressCommand.toolDefinition,
        SetTextCommand.toolDefinition,
        TypeTextCommand.toolDefinition,
        ClearCommand.toolDefinition,
        ScrollCommand.toolDefinition,
        SwipeCommand.toolDefinition,
        FocusCommand.toolDefinition,
        PressKeyCommand.toolDefinition,
        ToggleCommand.toolDefinition,
        SelectCommand.toolDefinition,
        WaitCommand.toolDefinition,
        BackCommand.toolDefinition,
        NavigateCommand.toolDefinition,
        GetTextCommand.toolDefinition,
        IsVisibleCommand.toolDefinition,
        ScreenshotCommand.toolDefinition,
      ];
}

// ══════════════════════════════════════════════════════════════════════════════
// INDIVIDUAL COMMAND TYPES
// ══════════════════════════════════════════════════════════════════════════════

/// Snapshot command - capture UI state.
class SnapshotCommand extends Command {
  @override
  CommandAction get action => CommandAction.snapshot;

  /// Maximum depth of tree to return (optional).
  final int? maxDepth;

  /// Scope snapshot to elements under this ref (optional).
  final String? selector;

  const SnapshotCommand({
    super.id,
    this.maxDepth,
    this.selector,
  });

  @override
  Map<String, dynamic> toJson() => {
        if (id != null) 'id': id,
        'action': 'snapshot',
        if (maxDepth != null) 'maxDepth': maxDepth,
        if (selector != null) 'selector': selector,
      };

  static SnapshotCommand fromJson(Map<String, dynamic> json, String? id) =>
      SnapshotCommand(
        id: id,
        maxDepth: json['maxDepth'] as int?,
        selector: json['selector'] as String?,
      );

  static Map<String, dynamic> get toolDefinition => {
        'name': 'snapshot',
        'description': '''Capture the current UI state of the Flutter app.

Returns a tree of user widgets with refs (w0, w1, w2...) that can be used
for subsequent interactions. Each element includes:
- ref: Stable identifier for this snapshot session
- widget: Widget type name  
- textContent: Text content for Text/Icon widgets
- bounds: Position {x, y, width, height}
- semantics: Label, value, actions, flags (on Semantics widgets)''',
        'inputSchema': {
          'type': 'object',
          'properties': {
            'maxDepth': {
              'type': 'integer',
              'description': 'Maximum tree depth to return (optional).',
            },
            'selector': {
              'type': 'string',
              'description': 'Scope to subtree under this ref (optional).',
            },
          },
        },
      };
}

/// Tap command - tap on an element.
class TapCommand extends Command {
  @override
  CommandAction get action => CommandAction.tap;

  /// Element ref to tap.
  final String ref;

  const TapCommand({super.id, required this.ref});

  @override
  Map<String, dynamic> toJson() => {
        if (id != null) 'id': id,
        'action': 'tap',
        'ref': ref,
      };

  static TapCommand fromJson(Map<String, dynamic> json, String? id) =>
      TapCommand(id: id, ref: json['ref'] as String);

  static Map<String, dynamic> get toolDefinition => {
        'name': 'tap',
        'description':
            'Tap on an element by ref. Use snapshot first to get refs.',
        'inputSchema': {
          'type': 'object',
          'properties': {
            'ref': {
              'type': 'string',
              'description': 'Element ref from snapshot (e.g., "w5").',
            },
          },
          'required': ['ref'],
        },
      };
}

/// TapAt command - tap at coordinates.
class TapAtCommand extends Command {
  @override
  CommandAction get action => CommandAction.tapAt;

  final double x;
  final double y;

  const TapAtCommand({super.id, required this.x, required this.y});

  @override
  Map<String, dynamic> toJson() => {
        if (id != null) 'id': id,
        'action': 'tapAt',
        'x': x,
        'y': y,
      };

  static TapAtCommand fromJson(Map<String, dynamic> json, String? id) =>
      TapAtCommand(
        id: id,
        x: (json['x'] as num).toDouble(),
        y: (json['y'] as num).toDouble(),
      );

  static Map<String, dynamic> get toolDefinition => {
        'name': 'tapAt',
        'description':
            'Tap at specific screen coordinates (logical pixels from top-left).',
        'inputSchema': {
          'type': 'object',
          'properties': {
            'x': {'type': 'number', 'description': 'X coordinate.'},
            'y': {'type': 'number', 'description': 'Y coordinate.'},
          },
          'required': ['x', 'y'],
        },
      };
}

/// DoubleTap command.
class DoubleTapCommand extends Command {
  @override
  CommandAction get action => CommandAction.doubleTap;

  final String ref;

  const DoubleTapCommand({super.id, required this.ref});

  @override
  Map<String, dynamic> toJson() => {
        if (id != null) 'id': id,
        'action': 'doubleTap',
        'ref': ref,
      };

  static DoubleTapCommand fromJson(Map<String, dynamic> json, String? id) =>
      DoubleTapCommand(id: id, ref: json['ref'] as String);

  static Map<String, dynamic> get toolDefinition => {
        'name': 'doubleTap',
        'description': 'Double tap on an element.',
        'inputSchema': {
          'type': 'object',
          'properties': {
            'ref': {'type': 'string', 'description': 'Element ref.'},
          },
          'required': ['ref'],
        },
      };
}

/// LongPress command.
class LongPressCommand extends Command {
  @override
  CommandAction get action => CommandAction.longPress;

  final String ref;
  final int? durationMs;

  const LongPressCommand({super.id, required this.ref, this.durationMs});

  @override
  Map<String, dynamic> toJson() => {
        if (id != null) 'id': id,
        'action': 'longPress',
        'ref': ref,
        if (durationMs != null) 'durationMs': durationMs,
      };

  static LongPressCommand fromJson(Map<String, dynamic> json, String? id) =>
      LongPressCommand(
        id: id,
        ref: json['ref'] as String,
        durationMs: json['durationMs'] as int?,
      );

  static Map<String, dynamic> get toolDefinition => {
        'name': 'longPress',
        'description': 'Long press on an element.',
        'inputSchema': {
          'type': 'object',
          'properties': {
            'ref': {'type': 'string', 'description': 'Element ref.'},
            'durationMs': {
              'type': 'integer',
              'description': 'Press duration in milliseconds. Default: 500.',
            },
          },
          'required': ['ref'],
        },
      };
}

/// SetText command - set text via semantic action.
class SetTextCommand extends Command {
  @override
  CommandAction get action => CommandAction.setText;

  final String ref;
  final String text;

  const SetTextCommand({super.id, required this.ref, required this.text});

  @override
  Map<String, dynamic> toJson() => {
        if (id != null) 'id': id,
        'action': 'setText',
        'ref': ref,
        'text': text,
      };

  static SetTextCommand fromJson(Map<String, dynamic> json, String? id) =>
      SetTextCommand(
        id: id,
        ref: json['ref'] as String,
        text: json['text'] as String,
      );

  static Map<String, dynamic> get toolDefinition => {
        'name': 'setText',
        'description': 'Set text on a field via semantic action. '
            'Use on Semantics widgets. For keyboard simulation, use typeText.',
        'inputSchema': {
          'type': 'object',
          'properties': {
            'ref': {'type': 'string', 'description': 'Semantics widget ref.'},
            'text': {'type': 'string', 'description': 'Text to set.'},
          },
          'required': ['ref', 'text'],
        },
      };
}

/// TypeText command - type text into a widget using keyboard simulation.
///
/// Unlike `setText` which uses semantic action, this uses platform message
/// simulation to type character by character like a real keyboard.
class TypeTextCommand extends Command {
  @override
  CommandAction get action => CommandAction.typeText;

  final String ref;
  final String text;
  final int? delayMs;

  const TypeTextCommand({
    super.id,
    required this.ref,
    required this.text,
    this.delayMs,
  });

  @override
  Map<String, dynamic> toJson() => {
        if (id != null) 'id': id,
        'action': 'typeText',
        'ref': ref,
        'text': text,
        if (delayMs != null) 'delayMs': delayMs,
      };

  static TypeTextCommand fromJson(Map<String, dynamic> json, String? id) =>
      TypeTextCommand(
        id: id,
        ref: json['ref'] as String,
        text: json['text'] as String,
        delayMs: json['delayMs'] as int?,
      );

  static Map<String, dynamic> get toolDefinition => {
        'name': 'typeText',
        'description': 'Type text into a widget using keyboard simulation. '
            'Use this for TextField widgets (e.g., w10). '
            'For Semantics widgets, use fill instead.',
        'inputSchema': {
          'type': 'object',
          'properties': {
            'ref': {
              'type': 'string',
              'description': 'Widget ref (e.g., w10 for TextField).',
            },
            'text': {'type': 'string', 'description': 'Text to type.'},
            'delayMs': {
              'type': 'integer',
              'description': 'Delay between characters in ms.',
            },
          },
          'required': ['ref', 'text'],
        },
      };
}

/// Clear command - clear text field.
class ClearCommand extends Command {
  @override
  CommandAction get action => CommandAction.clear;

  final String ref;

  const ClearCommand({super.id, required this.ref});

  @override
  Map<String, dynamic> toJson() => {
        if (id != null) 'id': id,
        'action': 'clear',
        'ref': ref,
      };

  static ClearCommand fromJson(Map<String, dynamic> json, String? id) =>
      ClearCommand(id: id, ref: json['ref'] as String);

  static Map<String, dynamic> get toolDefinition => {
        'name': 'clear',
        'description': 'Clear all text from a text field.',
        'inputSchema': {
          'type': 'object',
          'properties': {
            'ref': {'type': 'string', 'description': 'Text field ref.'},
          },
          'required': ['ref'],
        },
      };
}

/// Scroll command.
class ScrollCommand extends Command {
  @override
  CommandAction get action => CommandAction.scroll;

  final String ref;
  final String direction; // up, down, left, right
  final double? amount;

  const ScrollCommand({
    super.id,
    required this.ref,
    required this.direction,
    this.amount,
  });

  @override
  Map<String, dynamic> toJson() => {
        if (id != null) 'id': id,
        'action': 'scroll',
        'ref': ref,
        'direction': direction,
        if (amount != null) 'amount': amount,
      };

  static ScrollCommand fromJson(Map<String, dynamic> json, String? id) =>
      ScrollCommand(
        id: id,
        ref: json['ref'] as String,
        direction: json['direction'] as String,
        amount: (json['amount'] as num?)?.toDouble(),
      );

  static Map<String, dynamic> get toolDefinition => {
        'name': 'scroll',
        'description': 'Scroll a scrollable element.',
        'inputSchema': {
          'type': 'object',
          'properties': {
            'ref': {'type': 'string', 'description': 'Scrollable element ref.'},
            'direction': {
              'type': 'string',
              'enum': ['up', 'down', 'left', 'right'],
              'description': 'Scroll direction.',
            },
            'amount': {
              'type': 'number',
              'description': 'Scroll amount in pixels. Default: 300.',
            },
          },
          'required': ['ref', 'direction'],
        },
      };
}

/// Swipe command.
class SwipeCommand extends Command {
  @override
  CommandAction get action => CommandAction.swipe;

  final String direction; // up, down, left, right
  final double? startX;
  final double? startY;
  final double? distance;
  final int? durationMs;

  const SwipeCommand({
    super.id,
    required this.direction,
    this.startX,
    this.startY,
    this.distance,
    this.durationMs,
  });

  @override
  Map<String, dynamic> toJson() => {
        if (id != null) 'id': id,
        'action': 'swipe',
        'direction': direction,
        if (startX != null) 'startX': startX,
        if (startY != null) 'startY': startY,
        if (distance != null) 'distance': distance,
        if (durationMs != null) 'durationMs': durationMs,
      };

  static SwipeCommand fromJson(Map<String, dynamic> json, String? id) =>
      SwipeCommand(
        id: id,
        direction: json['direction'] as String,
        startX: (json['startX'] as num?)?.toDouble(),
        startY: (json['startY'] as num?)?.toDouble(),
        distance: (json['distance'] as num?)?.toDouble(),
        durationMs: json['durationMs'] as int?,
      );

  static Map<String, dynamic> get toolDefinition => {
        'name': 'swipe',
        'description':
            'Perform a swipe gesture. Useful for dismissing, navigating between pages.',
        'inputSchema': {
          'type': 'object',
          'properties': {
            'direction': {
              'type': 'string',
              'enum': ['up', 'down', 'left', 'right'],
              'description': 'Swipe direction.',
            },
            'startX': {
              'type': 'number',
              'description': 'Start X. Default: center of screen.',
            },
            'startY': {
              'type': 'number',
              'description': 'Start Y. Default: center of screen.',
            },
            'distance': {
              'type': 'number',
              'description': 'Swipe distance in pixels. Default: 200.',
            },
            'durationMs': {
              'type': 'integer',
              'description': 'Swipe duration in ms. Default: 300.',
            },
          },
          'required': ['direction'],
        },
      };
}

/// Focus command.
class FocusCommand extends Command {
  @override
  CommandAction get action => CommandAction.focus;

  final String ref;

  const FocusCommand({super.id, required this.ref});

  @override
  Map<String, dynamic> toJson() => {
        if (id != null) 'id': id,
        'action': 'focus',
        'ref': ref,
      };

  static FocusCommand fromJson(Map<String, dynamic> json, String? id) =>
      FocusCommand(id: id, ref: json['ref'] as String);

  static Map<String, dynamic> get toolDefinition => {
        'name': 'focus',
        'description': 'Focus on an element (for text input, etc.).',
        'inputSchema': {
          'type': 'object',
          'properties': {
            'ref': {'type': 'string', 'description': 'Element ref.'},
          },
          'required': ['ref'],
        },
      };
}

/// PressKey command.
class PressKeyCommand extends Command {
  @override
  CommandAction get action => CommandAction.pressKey;

  final String key;

  const PressKeyCommand({super.id, required this.key});

  @override
  Map<String, dynamic> toJson() => {
        if (id != null) 'id': id,
        'action': 'pressKey',
        'key': key,
      };

  static PressKeyCommand fromJson(Map<String, dynamic> json, String? id) =>
      PressKeyCommand(id: id, key: json['key'] as String);

  static Map<String, dynamic> get toolDefinition => {
        'name': 'pressKey',
        'description': '''Press a keyboard key.

Common keys: enter, tab, escape, backspace, delete,
arrowUp, arrowDown, arrowLeft, arrowRight''',
        'inputSchema': {
          'type': 'object',
          'properties': {
            'key': {'type': 'string', 'description': 'Key name to press.'},
          },
          'required': ['key'],
        },
      };
}

/// Toggle command - for switches/checkboxes.
class ToggleCommand extends Command {
  @override
  CommandAction get action => CommandAction.toggle;

  final String ref;
  final bool? value;

  const ToggleCommand({super.id, required this.ref, this.value});

  @override
  Map<String, dynamic> toJson() => {
        if (id != null) 'id': id,
        'action': 'toggle',
        'ref': ref,
        if (value != null) 'value': value,
      };

  static ToggleCommand fromJson(Map<String, dynamic> json, String? id) =>
      ToggleCommand(
        id: id,
        ref: json['ref'] as String,
        value: json['value'] as bool?,
      );

  static Map<String, dynamic> get toolDefinition => {
        'name': 'toggle',
        'description':
            'Toggle a switch or checkbox. Optionally set to specific value.',
        'inputSchema': {
          'type': 'object',
          'properties': {
            'ref': {'type': 'string', 'description': 'Element ref.'},
            'value': {
              'type': 'boolean',
              'description':
                  'Set to specific value, or toggle if not provided.',
            },
          },
          'required': ['ref'],
        },
      };
}

/// Select command - for dropdowns.
class SelectCommand extends Command {
  @override
  CommandAction get action => CommandAction.select;

  final String ref;
  final String value;

  const SelectCommand({super.id, required this.ref, required this.value});

  @override
  Map<String, dynamic> toJson() => {
        if (id != null) 'id': id,
        'action': 'select',
        'ref': ref,
        'value': value,
      };

  static SelectCommand fromJson(Map<String, dynamic> json, String? id) =>
      SelectCommand(
        id: id,
        ref: json['ref'] as String,
        value: json['value'] as String,
      );

  static Map<String, dynamic> get toolDefinition => {
        'name': 'select',
        'description': 'Select an option from a dropdown menu.',
        'inputSchema': {
          'type': 'object',
          'properties': {
            'ref': {'type': 'string', 'description': 'Dropdown ref.'},
            'value': {
              'type': 'string',
              'description': 'Value/label to select.',
            },
          },
          'required': ['ref', 'value'],
        },
      };
}

/// Wait command.
class WaitCommand extends Command {
  @override
  CommandAction get action => CommandAction.wait;

  final int? milliseconds;
  final String? forRef;
  final String? state; // visible, hidden, enabled, disabled

  const WaitCommand({
    super.id,
    this.milliseconds,
    this.forRef,
    this.state,
  });

  @override
  Map<String, dynamic> toJson() => {
        if (id != null) 'id': id,
        'action': 'wait',
        if (milliseconds != null) 'milliseconds': milliseconds,
        if (forRef != null) 'for': forRef,
        if (state != null) 'state': state,
      };

  static WaitCommand fromJson(Map<String, dynamic> json, String? id) =>
      WaitCommand(
        id: id,
        milliseconds: json['milliseconds'] as int?,
        forRef: json['for'] as String?,
        state: json['state'] as String?,
      );

  static Map<String, dynamic> get toolDefinition => {
        'name': 'wait',
        'description': '''Wait for a duration or condition.

Either specify milliseconds for a fixed wait, or wait for an element
to reach a specific state.''',
        'inputSchema': {
          'type': 'object',
          'properties': {
            'milliseconds': {
              'type': 'integer',
              'description': 'Fixed wait duration.',
            },
            'for': {
              'type': 'string',
              'description': 'Wait for this element ref.',
            },
            'state': {
              'type': 'string',
              'enum': ['visible', 'hidden', 'enabled', 'disabled'],
              'description': 'State to wait for.',
            },
          },
        },
      };
}

/// Back command - pop navigation.
class BackCommand extends Command {
  @override
  CommandAction get action => CommandAction.back;

  const BackCommand({super.id});

  @override
  Map<String, dynamic> toJson() => {
        if (id != null) 'id': id,
        'action': 'back',
      };

  static BackCommand fromJson(Map<String, dynamic> json, String? id) =>
      BackCommand(id: id);

  static Map<String, dynamic> get toolDefinition => {
        'name': 'back',
        'description': 'Navigate back (pop the navigation stack).',
        'inputSchema': {'type': 'object', 'properties': {}},
      };
}

/// Navigate command - go to route.
class NavigateCommand extends Command {
  @override
  CommandAction get action => CommandAction.navigate;

  final String route;
  final Map<String, dynamic>? arguments;

  const NavigateCommand({super.id, required this.route, this.arguments});

  @override
  Map<String, dynamic> toJson() => {
        if (id != null) 'id': id,
        'action': 'navigate',
        'route': route,
        if (arguments != null) 'arguments': arguments,
      };

  static NavigateCommand fromJson(Map<String, dynamic> json, String? id) =>
      NavigateCommand(
        id: id,
        route: json['route'] as String,
        arguments: json['arguments'] as Map<String, dynamic>?,
      );

  static Map<String, dynamic> get toolDefinition => {
        'name': 'navigate',
        'description': 'Navigate to a named route.',
        'inputSchema': {
          'type': 'object',
          'properties': {
            'route': {'type': 'string', 'description': 'Route name.'},
            'arguments': {
              'type': 'object',
              'description': 'Route arguments.',
            },
          },
          'required': ['route'],
        },
      };
}

/// GetText command - get element text.
class GetTextCommand extends Command {
  @override
  CommandAction get action => CommandAction.getText;

  final String ref;

  const GetTextCommand({super.id, required this.ref});

  @override
  Map<String, dynamic> toJson() => {
        if (id != null) 'id': id,
        'action': 'getText',
        'ref': ref,
      };

  static GetTextCommand fromJson(Map<String, dynamic> json, String? id) =>
      GetTextCommand(id: id, ref: json['ref'] as String);

  static Map<String, dynamic> get toolDefinition => {
        'name': 'getText',
        'description': 'Get the text content of an element.',
        'inputSchema': {
          'type': 'object',
          'properties': {
            'ref': {'type': 'string', 'description': 'Element ref.'},
          },
          'required': ['ref'],
        },
      };
}

/// IsVisible command.
class IsVisibleCommand extends Command {
  @override
  CommandAction get action => CommandAction.isVisible;

  final String ref;

  const IsVisibleCommand({super.id, required this.ref});

  @override
  Map<String, dynamic> toJson() => {
        if (id != null) 'id': id,
        'action': 'isVisible',
        'ref': ref,
      };

  static IsVisibleCommand fromJson(Map<String, dynamic> json, String? id) =>
      IsVisibleCommand(id: id, ref: json['ref'] as String);

  static Map<String, dynamic> get toolDefinition => {
        'name': 'isVisible',
        'description': 'Check if an element is visible on screen.',
        'inputSchema': {
          'type': 'object',
          'properties': {
            'ref': {'type': 'string', 'description': 'Element ref.'},
          },
          'required': ['ref'],
        },
      };
}

/// Screenshot command.
class ScreenshotCommand extends Command {
  @override
  CommandAction get action => CommandAction.screenshot;

  final String? selector;
  final bool fullPage;

  const ScreenshotCommand({super.id, this.selector, this.fullPage = false});

  @override
  Map<String, dynamic> toJson() => {
        if (id != null) 'id': id,
        'action': 'screenshot',
        if (selector != null) 'selector': selector,
        'fullPage': fullPage,
      };

  static ScreenshotCommand fromJson(Map<String, dynamic> json, String? id) =>
      ScreenshotCommand(
        id: id,
        selector: json['selector'] as String?,
        fullPage: json['fullPage'] as bool? ?? false,
      );

  static Map<String, dynamic> get toolDefinition => {
        'name': 'screenshot',
        'description': 'Take a screenshot. Returns base64-encoded PNG.',
        'inputSchema': {
          'type': 'object',
          'properties': {
            'selector': {
              'type': 'string',
              'description': 'Capture only this element.',
            },
            'fullPage': {
              'type': 'boolean',
              'description': 'Capture entire scrollable area.',
            },
          },
        },
      };
}

// ══════════════════════════════════════════════════════════════════════════════
// RESPONSE TYPES
// ══════════════════════════════════════════════════════════════════════════════

/// Result of parsing a command.
class ParseResult {
  final bool isValid;
  final Command? command;
  final String? error;
  final String? id;

  const ParseResult._({
    required this.isValid,
    this.command,
    this.error,
    this.id,
  });

  factory ParseResult.success(Command command) => ParseResult._(
        isValid: true,
        command: command,
        id: command.id,
      );

  factory ParseResult.error(String error, {String? id}) => ParseResult._(
        isValid: false,
        error: error,
        id: id,
      );
}

/// Response from executing a command.
class CommandResponse {
  final String? id;
  final bool success;
  final dynamic data;
  final String? error;

  const CommandResponse({
    this.id,
    required this.success,
    this.data,
    this.error,
  });

  factory CommandResponse.ok(String? id, [dynamic data]) => CommandResponse(
        id: id,
        success: true,
        data: data,
      );

  factory CommandResponse.fail(String? id, String error) => CommandResponse(
        id: id,
        success: false,
        error: error,
      );

  Map<String, dynamic> toJson() => {
        if (id != null) 'id': id,
        'success': success,
        if (data != null) 'data': data,
        if (error != null) 'error': error,
      };

  String serialize() => jsonEncode(toJson());
}

// ══════════════════════════════════════════════════════════════════════════════
// HELPERS
// ══════════════════════════════════════════════════════════════════════════════

extension _EnumByName on List<CommandAction> {
  CommandAction? asNameByValue(String name) {
    for (final value in this) {
      if (value.name == name) return value;
    }
    return null;
  }
}

ParseResult _parseCommand(
  CommandAction action,
  Map<String, dynamic> json,
  String? id,
) {
  try {
    final command = switch (action) {
      CommandAction.snapshot => SnapshotCommand.fromJson(json, id),
      CommandAction.tap => TapCommand.fromJson(json, id),
      CommandAction.tapAt => TapAtCommand.fromJson(json, id),
      CommandAction.doubleTap => DoubleTapCommand.fromJson(json, id),
      CommandAction.longPress => LongPressCommand.fromJson(json, id),
      CommandAction.setText => SetTextCommand.fromJson(json, id),
      CommandAction.typeText => TypeTextCommand.fromJson(json, id),
      CommandAction.clear => ClearCommand.fromJson(json, id),
      CommandAction.scroll => ScrollCommand.fromJson(json, id),
      CommandAction.swipe => SwipeCommand.fromJson(json, id),
      CommandAction.focus => FocusCommand.fromJson(json, id),
      CommandAction.pressKey => PressKeyCommand.fromJson(json, id),
      CommandAction.toggle => ToggleCommand.fromJson(json, id),
      CommandAction.select => SelectCommand.fromJson(json, id),
      CommandAction.wait => WaitCommand.fromJson(json, id),
      CommandAction.back => BackCommand.fromJson(json, id),
      CommandAction.navigate => NavigateCommand.fromJson(json, id),
      CommandAction.getText => GetTextCommand.fromJson(json, id),
      CommandAction.isVisible => IsVisibleCommand.fromJson(json, id),
      CommandAction.screenshot => ScreenshotCommand.fromJson(json, id),
      _ => throw UnimplementedError('Command not implemented: $action'),
    };
    return ParseResult.success(command);
  } catch (e) {
    return ParseResult.error('Invalid command arguments: $e', id: id);
  }
}

// ════════════════════════════════════════════════════════════════════════════
// Source: package:flutter_mate/src/actions/helpers.dart
// ════════════════════════════════════════════════════════════════════════════

/// Find a semantics node by ref
///
/// Looks up the semantics ID from the cached snapshot and searches
/// the semantics tree for the matching node.
SemanticsNode? findSemanticsNode(String ref) {
  // Clean ref: '@w5' -> 'w5'
  final cleanRef = ref.startsWith('@') ? ref.substring(1) : ref;
  if (!cleanRef.startsWith('w')) return null;

  // Look up semantics ID from cached snapshot
  final lastSnapshot = FlutterMate.lastSnapshot;
  if (lastSnapshot != null) {
    final node = lastSnapshot[cleanRef];
    if (node?.semantics != null) {
      final semanticsId = node!.semantics!.id;
      return searchSemanticsNodeById(semanticsId);
    }
  }

  // Fallback: try parsing ref as semantics ID directly (backwards compat)
  final nodeId = int.tryParse(cleanRef.substring(1));
  if (nodeId == null) return null;
  return searchSemanticsNodeById(nodeId);
}

/// Find element ref by text content or semantic label.
///
/// Searches the current snapshot for an element whose text contains
/// the given string (case-insensitive).
///
/// Searches (in order):
/// - `textContent` (from Text/RichText widgets)
/// - `semantics.label`
/// - `semantics.value`
/// - `semantics.hint`
///
/// ```dart
/// final ref = await findByLabel('Email');
/// if (ref != null) {
///   await FlutterMate.setText(ref, 'test@example.com');
/// }
/// ```
Future<String?> findByLabel(String label) async {
  FlutterMate.ensureInitialized();

  final snap = await SnapshotService.snapshot();
  final lowerLabel = label.toLowerCase();

  for (final node in snap.nodes) {
    // Check textContent first
    final textContent = node.textContent;
    if (textContent != null && textContent.toLowerCase().contains(lowerLabel)) {
      return node.ref;
    }

    // Check semantics fields
    final nodeLabel = node.semantics?.label;
    if (nodeLabel != null && nodeLabel.toLowerCase().contains(lowerLabel)) {
      return node.ref;
    }

    final nodeValue = node.semantics?.value;
    if (nodeValue != null && nodeValue.toLowerCase().contains(lowerLabel)) {
      return node.ref;
    }

    final nodeHint = node.semantics?.hint;
    if (nodeHint != null && nodeHint.toLowerCase().contains(lowerLabel)) {
      return node.ref;
    }
  }

  return null;
}

/// Find all element refs matching a text pattern.
///
/// Returns all refs whose text matches the pattern (regex, case-insensitive).
///
/// Searches:
/// - `textContent` (from Text/RichText widgets)
/// - `semantics.label`
/// - `semantics.value`
/// - `semantics.hint`
///
/// ```dart
/// final refs = await findAllByLabel('Item');
/// for (final ref in refs) {
///   await FlutterMate.tap(ref);
/// }
/// ```
Future<List<String>> findAllByLabel(String labelPattern) async {
  FlutterMate.ensureInitialized();

  final snap = await SnapshotService.snapshot();
  final pattern = RegExp(labelPattern, caseSensitive: false);
  final refs = <String>[];

  for (final node in snap.nodes) {
    bool matched = false;

    // Check textContent first
    final textContent = node.textContent;
    if (textContent != null && pattern.hasMatch(textContent)) {
      matched = true;
    }

    // Check semantics fields
    if (!matched) {
      final label = node.semantics?.label;
      if (label != null && pattern.hasMatch(label)) {
        matched = true;
      }
    }

    if (!matched) {
      final value = node.semantics?.value;
      if (value != null && pattern.hasMatch(value)) {
        matched = true;
      }
    }

    if (!matched) {
      final hint = node.semantics?.hint;
      if (hint != null && pattern.hasMatch(hint)) {
        matched = true;
      }
    }

    if (matched) {
      refs.add(node.ref);
    }
  }

  return refs;
}

/// Wait for an element with matching text to appear.
///
/// Polls the snapshot until an element with text matching the pattern
/// is found, or timeout is reached.
///
/// Searches (in order):
/// - `textContent` (from Text/RichText widgets)
/// - `semantics.label`
/// - `semantics.value`
/// - `semantics.hint`
///
/// Returns the element's ref if found, null if timeout.
Future<String?> waitFor(
  String labelPattern, {
  Duration timeout = const Duration(seconds: 5),
  Duration pollInterval = const Duration(milliseconds: 200),
}) async {
  FlutterMate.ensureInitialized();

  final pattern = RegExp(labelPattern, caseSensitive: false);
  final deadline = DateTime.now().add(timeout);

  while (DateTime.now().isBefore(deadline)) {
    final snap = await SnapshotService.snapshot();
    for (final node in snap.nodes) {
      // Check textContent first (from Text/RichText widgets)
      final textContent = node.textContent;
      if (textContent != null && pattern.hasMatch(textContent)) {
        return node.ref;
      }

      // Check semantics fields
      final label = node.semantics?.label;
      if (label != null && pattern.hasMatch(label)) {
        return node.ref;
      }

      final value = node.semantics?.value;
      if (value != null && pattern.hasMatch(value)) {
        return node.ref;
      }

      final hint = node.semantics?.hint;
      if (hint != null && pattern.hasMatch(hint)) {
        return node.ref;
      }
    }
    await FlutterMate.delay(pollInterval);
  }

  return null;
}

// ════════════════════════════════════════════════════════════════════════════
// Source: package:flutter_mate/src/command_executor.dart
// ════════════════════════════════════════════════════════════════════════════

/// CommandExecutor - Bridge between Protocol commands and FlutterMate SDK
///
/// This executor takes typed [Command] objects from protocol.dart and
/// executes them via the FlutterMate SDK, returning [CommandResponse] objects.
///
/// ## Usage
///
/// ```dart
/// // Parse a command from JSON
/// final result = Command.parse('{"action": "tap", "ref": "w5"}');
/// if (result.isValid) {
///   final response = await CommandExecutor.execute(result.command!);
///   print(response.success ? 'OK' : response.error);
/// }
/// ```

/// Executes [Command] objects via the FlutterMate SDK.
class CommandExecutor {
  CommandExecutor._();

  /// Execute a single command.
  ///
  /// Returns a [CommandResponse] with success status and any result data.
  static Future<CommandResponse> execute(Command command) async {
    try {
      return switch (command) {
        SnapshotCommand cmd => _executeSnapshot(cmd),
        TapCommand cmd => _executeTap(cmd),
        TapAtCommand cmd => _executeTapAt(cmd),
        DoubleTapCommand cmd => _executeDoubleTap(cmd),
        LongPressCommand cmd => _executeLongPress(cmd),
        SetTextCommand cmd => _executeSetText(cmd),
        TypeTextCommand cmd => _executeTypeText(cmd),
        ClearCommand cmd => _executeClear(cmd),
        ScrollCommand cmd => _executeScroll(cmd),
        SwipeCommand cmd => _executeSwipe(cmd),
        FocusCommand cmd => _executeFocus(cmd),
        PressKeyCommand cmd => _executePressKey(cmd),
        ToggleCommand cmd => _executeToggle(cmd),
        SelectCommand cmd => _executeSelect(cmd),
        WaitCommand cmd => _executeWait(cmd),
        BackCommand cmd => _executeBack(cmd),
        NavigateCommand cmd => _executeNavigate(cmd),
        GetTextCommand cmd => _executeGetText(cmd),
        IsVisibleCommand cmd => _executeIsVisible(cmd),
        ScreenshotCommand cmd => _executeScreenshot(cmd),
        _ => throw UnimplementedError(
            'Command not implemented: ${command.action}'),
      };
    } catch (e, stack) {
      return CommandResponse.fail(
        command.id,
        'Execution error: $e\n$stack',
      );
    }
  }

  /// Execute a command from JSON (parses then executes).
  static Future<CommandResponse> executeJson(dynamic json) async {
    final result = Command.parse(json);
    if (!result.isValid) {
      return CommandResponse.fail(result.id, result.error!);
    }
    return execute(result.command!);
  }

  /// Execute a sequence of commands.
  ///
  /// Stops on first failure unless [continueOnError] is true.
  static Future<List<CommandResponse>> executeSequence(
    List<Command> commands, {
    bool continueOnError = false,
  }) async {
    final responses = <CommandResponse>[];

    for (final command in commands) {
      final response = await execute(command);
      responses.add(response);

      if (!response.success && !continueOnError) {
        break;
      }
    }

    return responses;
  }

  // ════════════════════════════════════════════════════════════════════════════
  // Command Handlers
  // ════════════════════════════════════════════════════════════════════════════

  static Future<CommandResponse> _executeSnapshot(SnapshotCommand cmd) async {
    final snapshot = await SnapshotService.snapshot();

    if (!snapshot.success) {
      return CommandResponse.fail(cmd.id, snapshot.error ?? 'Snapshot failed');
    }

    var nodes = snapshot.nodes;

    // Apply maxDepth filter if specified
    if (cmd.maxDepth != null) {
      nodes = nodes.where((n) => n.depth <= cmd.maxDepth!).toList();
    }

    // Apply selector filter if specified
    if (cmd.selector != null) {
      // Find the subtree under the selector
      final selectorNode = nodes.firstWhere(
        (n) => n.ref == cmd.selector,
        orElse: () => nodes.first,
      );
      // Filter to only include descendants
      nodes = nodes.where((n) {
        // Simple heuristic: check if ref starts after selector in order
        final selectorIdx = int.tryParse(selectorNode.ref.substring(1)) ?? 0;
        final nodeIdx = int.tryParse(n.ref.substring(1)) ?? 0;
        return nodeIdx >= selectorIdx;
      }).toList();
    }

    return CommandResponse.ok(cmd.id, {
      'nodeCount': nodes.length,
      'nodes': nodes.map((n) => n.toJson()).toList(),
    });
  }

  static Future<CommandResponse> _executeTap(TapCommand cmd) async {
    final success = await SemanticActions.tap(cmd.ref);
    if (success) {
      return CommandResponse.ok(cmd.id);
    }
    return CommandResponse.fail(cmd.id, 'Failed to tap element: ${cmd.ref}');
  }

  static Future<CommandResponse> _executeTapAt(TapAtCommand cmd) async {
    await GestureActions.tapAt(ui.Offset(cmd.x, cmd.y));
    return CommandResponse.ok(cmd.id);
  }

  static Future<CommandResponse> _executeDoubleTap(DoubleTapCommand cmd) async {
    // Double tap: tap twice quickly
    final success1 = await SemanticActions.tap(cmd.ref);
    if (!success1) {
      return CommandResponse.fail(
          cmd.id, 'Failed to double tap element: ${cmd.ref}');
    }
    await Future.delayed(const Duration(milliseconds: 50));
    final success2 = await SemanticActions.tap(cmd.ref);
    if (!success2) {
      return CommandResponse.fail(
          cmd.id, 'Failed to complete double tap: ${cmd.ref}');
    }
    return CommandResponse.ok(cmd.id);
  }

  static Future<CommandResponse> _executeLongPress(LongPressCommand cmd) async {
    final success = await SemanticActions.longPress(cmd.ref);
    if (success) {
      return CommandResponse.ok(cmd.id);
    }
    return CommandResponse.fail(
        cmd.id, 'Failed to long press element: ${cmd.ref}');
  }

  static Future<CommandResponse> _executeSetText(SetTextCommand cmd) async {
    final success = await SemanticActions.setText(cmd.ref, cmd.text);
    if (success) {
      return CommandResponse.ok(cmd.id);
    }
    return CommandResponse.fail(
        cmd.id, 'Failed to setText on element: ${cmd.ref}');
  }

  static Future<CommandResponse> _executeTypeText(TypeTextCommand cmd) async {
    final success = await KeyboardActions.typeText(cmd.ref, cmd.text);
    if (success) {
      return CommandResponse.ok(cmd.id);
    }
    return CommandResponse.fail(
        cmd.id, 'Failed to type text into element: ${cmd.ref}');
  }

  static Future<CommandResponse> _executeClear(ClearCommand cmd) async {
    // Focus the element first, then clear
    final focused = await SemanticActions.focus(cmd.ref);
    if (!focused) {
      return CommandResponse.fail(
          cmd.id, 'Failed to focus element for clear: ${cmd.ref}');
    }
    final success = await KeyboardActions.clearText();
    if (success) {
      return CommandResponse.ok(cmd.id);
    }
    return CommandResponse.fail(cmd.id, 'Failed to clear text field');
  }

  static Future<CommandResponse> _executeScroll(ScrollCommand cmd) async {
    final direction = switch (cmd.direction.toLowerCase()) {
      'up' => ScrollDirection.up,
      'down' => ScrollDirection.down,
      'left' => ScrollDirection.left,
      'right' => ScrollDirection.right,
      _ => null,
    };

    if (direction == null) {
      return CommandResponse.fail(
          cmd.id, 'Invalid direction: ${cmd.direction}');
    }

    final success = await SemanticActions.scroll(cmd.ref, direction);
    if (success) {
      return CommandResponse.ok(cmd.id);
    }
    return CommandResponse.fail(cmd.id, 'Failed to scroll element: ${cmd.ref}');
  }

  static Future<CommandResponse> _executeSwipe(SwipeCommand cmd) async {
    // Get screen size for default center position
    final window = WidgetsBinding.instance.platformDispatcher.views.first;
    final screenSize = window.physicalSize / window.devicePixelRatio;

    final startX = cmd.startX ?? screenSize.width / 2;
    final startY = cmd.startY ?? screenSize.height / 2;
    final distance = cmd.distance ?? 200.0;
    final duration = cmd.durationMs ?? 300;

    // Calculate end position based on direction
    double endX = startX;
    double endY = startY;

    switch (cmd.direction.toLowerCase()) {
      case 'up':
        endY = startY - distance;
      case 'down':
        endY = startY + distance;
      case 'left':
        endX = startX - distance;
      case 'right':
        endX = startX + distance;
      default:
        return CommandResponse.fail(
            cmd.id, 'Invalid swipe direction: ${cmd.direction}');
    }

    // Perform drag gesture
    await GestureActions.drag(
      from: ui.Offset(startX, startY),
      to: ui.Offset(endX, endY),
      duration: Duration(milliseconds: duration),
    );

    return CommandResponse.ok(cmd.id);
  }

  static Future<CommandResponse> _executeFocus(FocusCommand cmd) async {
    final success = await SemanticActions.focus(cmd.ref);
    if (success) {
      return CommandResponse.ok(cmd.id);
    }
    return CommandResponse.fail(cmd.id, 'Failed to focus element: ${cmd.ref}');
  }

  static Future<CommandResponse> _executePressKey(PressKeyCommand cmd) async {
    switch (cmd.key.toLowerCase()) {
      case 'enter':
        await KeyboardActions.pressEnter();
      case 'tab':
        await KeyboardActions.pressTab();
      case 'escape':
        await KeyboardActions.pressEscape();
      case 'backspace':
        await KeyboardActions.pressBackspace();
      case 'arrowup':
        await KeyboardActions.pressArrowUp();
      case 'arrowdown':
        await KeyboardActions.pressArrowDown();
      case 'arrowleft':
        await KeyboardActions.pressArrowLeft();
      case 'arrowright':
        await KeyboardActions.pressArrowRight();
      default:
        return CommandResponse.fail(cmd.id, 'Unknown key: ${cmd.key}');
    }
    return CommandResponse.ok(cmd.id);
  }

  static Future<CommandResponse> _executeToggle(ToggleCommand cmd) async {
    // Toggle is just a tap on the switch/checkbox
    // If value is specified, we need to check current state first
    // For now, just tap
    final success = await SemanticActions.tap(cmd.ref);
    if (success) {
      return CommandResponse.ok(cmd.id);
    }
    return CommandResponse.fail(cmd.id, 'Failed to toggle element: ${cmd.ref}');
  }

  static Future<CommandResponse> _executeSelect(SelectCommand cmd) async {
    // Select: tap to open dropdown, then find and tap the option
    // Step 1: Tap the dropdown
    final opened = await SemanticActions.tap(cmd.ref);
    if (!opened) {
      return CommandResponse.fail(
          cmd.id, 'Failed to open dropdown: ${cmd.ref}');
    }

    // Wait for dropdown to open
    await Future.delayed(const Duration(milliseconds: 200));

    // Step 2: Find the option by value/label
    final optionRef = await waitFor(cmd.value);
    if (optionRef == null) {
      return CommandResponse.fail(cmd.id, 'Option not found: ${cmd.value}');
    }

    // Step 3: Tap the option
    final selected = await SemanticActions.tap(optionRef);
    if (selected) {
      return CommandResponse.ok(cmd.id);
    }
    return CommandResponse.fail(
        cmd.id, 'Failed to select option: ${cmd.value}');
  }

  static Future<CommandResponse> _executeWait(WaitCommand cmd) async {
    if (cmd.milliseconds != null) {
      // Fixed duration wait
      await Future.delayed(Duration(milliseconds: cmd.milliseconds!));
      return CommandResponse.ok(cmd.id);
    }

    if (cmd.forRef != null) {
      // Wait for element
      const timeout = Duration(seconds: 10);
      final startTime = DateTime.now();

      while (DateTime.now().difference(startTime) < timeout) {
        final snapshot = await SnapshotService.snapshot();
        final node = snapshot.nodes.firstWhere(
          (n) => n.ref == cmd.forRef,
          orElse: () => snapshot.nodes.first,
        );

        if (node.ref == cmd.forRef) {
          // Check state if specified
          if (cmd.state == null) {
            return CommandResponse.ok(cmd.id);
          }

          // TODO: Implement state checking
          return CommandResponse.ok(cmd.id);
        }

        await Future.delayed(const Duration(milliseconds: 100));
      }

      return CommandResponse.fail(
          cmd.id, 'Timeout waiting for element: ${cmd.forRef}');
    }

    // Default: wait 1 second
    await Future.delayed(const Duration(seconds: 1));
    return CommandResponse.ok(cmd.id);
  }

  static Future<CommandResponse> _executeBack(BackCommand cmd) async {
    // Try to use the back action from semantics
    // Look for a back button or use navigation pop
    final snapshot = await SnapshotService.snapshot();

    // Look for back button
    for (final node in snapshot.nodes) {
      final label = node.semantics?.label?.toLowerCase() ?? '';
      if (label.contains('back') || label.contains('pop')) {
        final success = await SemanticActions.tap(node.ref);
        if (success) {
          return CommandResponse.ok(cmd.id);
        }
      }
    }

    // Fallback: press escape or back key
    await KeyboardActions.pressEscape();
    return CommandResponse.ok(cmd.id);
  }

  static Future<CommandResponse> _executeNavigate(NavigateCommand cmd) async {
    // Navigation requires access to Navigator, which we can't do directly
    // from semantics. This would need a service extension in the app.
    // For now, return not implemented.
    return CommandResponse.fail(
      cmd.id,
      'Navigate command requires app-side implementation. '
      'Use tap on navigation elements instead.',
    );
  }

  static Future<CommandResponse> _executeGetText(GetTextCommand cmd) async {
    final snapshot = await SnapshotService.snapshot();
    final node = snapshot[cmd.ref];

    if (node == null) {
      return CommandResponse.fail(cmd.id, 'Element not found: ${cmd.ref}');
    }

    final text = node.semantics?.label ?? node.semantics?.value ?? node.widget;

    return CommandResponse.ok(cmd.id, {'text': text});
  }

  static Future<CommandResponse> _executeIsVisible(IsVisibleCommand cmd) async {
    final snapshot = await SnapshotService.snapshot();
    final node = snapshot[cmd.ref];

    if (node == null) {
      return CommandResponse.ok(cmd.id, {'visible': false});
    }

    // Check if bounds are valid (element is rendered)
    final isVisible = node.bounds != null &&
        node.bounds!.width > 0 &&
        node.bounds!.height > 0;

    return CommandResponse.ok(cmd.id, {'visible': isVisible});
  }

  static Future<CommandResponse> _executeScreenshot(
      ScreenshotCommand cmd) async {
    try {
      // Find the root RenderRepaintBoundary
      final renderObject = WidgetsBinding.instance.rootElement?.renderObject;
      if (renderObject == null) {
        return CommandResponse.fail(cmd.id, 'No render object found');
      }

      // Find a RenderRepaintBoundary
      RenderRepaintBoundary? boundary;
      void findBoundary(RenderObject obj) {
        if (obj is RenderRepaintBoundary) {
          boundary = obj;
          return;
        }
        obj.visitChildren(findBoundary);
      }

      findBoundary(renderObject);

      if (boundary == null) {
        return CommandResponse.fail(cmd.id, 'No repaint boundary found');
      }

      // Capture the image
      final image = await boundary!.toImage(pixelRatio: 2.0);
      final byteData = await image.toByteData(format: ui.ImageByteFormat.png);

      if (byteData == null) {
        return CommandResponse.fail(cmd.id, 'Failed to capture image');
      }

      // Return base64 encoded PNG
      final base64 = base64Encode(byteData.buffer.asUint8List());
      return CommandResponse.ok(cmd.id, {
        'format': 'png',
        'data': base64,
        'width': image.width,
        'height': image.height,
      });
    } catch (e) {
      return CommandResponse.fail(cmd.id, 'Screenshot failed: $e');
    }
  }
}

